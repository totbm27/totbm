// original test path: /Users/curtis/Github/Thesis/chatTester/Repos/tabulapdf_tabula-java/src/test/java/technology/tabula/RectangularTextContainer_ESTest.java
/*
 * This file was automatically generated by EvoSuite
 * Sat Feb 10 10:07:21 GMT 2024
 */
package technology.tabula;



import java.util.ArrayList;
import java.util.*;
import java.lang.*;
import org.junit.Test;
import static org.junit.Assert.*;
import static org.evosuite.runtime.EvoAssertions.*;
import java.awt.geom.Point2D;
import java.util.List;
import org.evosuite.runtime.EvoRunner;
import org.evosuite.runtime.EvoRunnerParameters;
import org.junit.runner.RunWith;
import technology.tabula.Cell;
import technology.tabula.RectangularTextContainer;
import technology.tabula.TextChunk;
import technology.tabula.TextElement;

@RunWith(EvoRunner.class)
@EvoRunnerParameters(mockJVMNonDeterminism = true, useVFS = true, useVNET = true, resetStaticState = true, separateClassLoader = false)
public class RectangularTextContainer_ESTest extends RectangularTextContainer_ESTest_scaffolding {

    
    
@Test
public void testMerge_combinesTextElementsInCorrectOrderAndUpdatesProperties() {
    // Arrange:
    // Create a concrete subclass with mutable text elements and implement compareTo and merge
    class TestRectangularTextContainer extends RectangularTextContainer<TestRectangularTextContainer> implements Comparable<TestRectangularTextContainer> {
        private List<String> textElements = new ArrayList<>();
        private float top, left, width, height;

        public TestRectangularTextContainer(float top, float left, float width, float height) {
            super(top, left, width, height);
            this.top = top;
            this.left = left;
            this.width = width;
            this.height = height;
        }

        public List<String> getTextElements() {
            return textElements;
        }

        // Compare based on top coordinate
        @Override
        public int compareTo(TestRectangularTextContainer other) {
            return Float.compare(this.top, other.top);
        }

        // Override merge to combine text elements and update bounding box simulating super.merge
        @Override
        public TestRectangularTextContainer merge(TestRectangularTextContainer other) {
            if (compareTo(other) < 0) {
                this.getTextElements().addAll(other.getTextElements());
            } else {
                this.getTextElements().addAll(0, other.getTextElements());
            }
            // Update bounding box to include both rectangles
            this.top = Math.min(this.top, other.top);
            this.left = Math.min(this.left, other.left);
            this.width = Math.max(this.left + this.width, other.left + other.width) - this.left;
            this.height = Math.max(this.top + this.height, other.top + other.height) - this.top;
            return this;
        }

        // Getters for bounding box
        public float getTop() { return top; }
        public float getLeft() { return left; }
        public float getWidth() { return width; }
        public float getHeight() { return height; }
    }

    TestRectangularTextContainer container1 = new TestRectangularTextContainer(10, 10, 50, 50);
    container1.getTextElements().add("A");
    container1.getTextElements().add("B");

    TestRectangularTextContainer container2 = new TestRectangularTextContainer(20, 5, 30, 40);
    container2.getTextElements().add("C");
    container2.getTextElements().add("D");

    // Act:
    TestRectangularTextContainer mergedLower = container1.merge(container2); // container1.top < container2.top

    // Reset containers for second scenario
    container1 = new TestRectangularTextContainer(20, 10, 50, 50);
    container1.getTextElements().add("A");
    container1.getTextElements().add("B");

    container2 = new TestRectangularTextContainer(10, 5, 30, 40);
    container2.getTextElements().add("C");
    container2.getTextElements().add("D");

    TestRectangularTextContainer mergedHigher = container1.merge(container2); // container1.top > container2.top

    // Assert:
    // When this < other, other elements appended at end
    List<String> expectedOrder1 = List.of("A", "B", "C", "D");
    assertEquals(expectedOrder1, mergedLower.getTextElements(), "Text elements should be appended at the end when this < other");

    // Bounding box updated to include both containers
    assertEquals(10f, mergedLower.getTop(), 0.0001f);
    assertEquals(5f, mergedLower.getLeft(), 0.0001f);
    assertEquals(55f, mergedLower.getWidth(), 0.0001f); // max(10+50=60, 5+30=35)-5=55
    assertEquals(50f, mergedLower.getHeight(), 0.0001f); // max(10+50=60, 20+40=60)-10=50

    // When this > other, other elements inserted at front
    List<String> expectedOrder2 = List.of("C", "D", "A", "B");
    assertEquals(expectedOrder2, mergedHigher.getTextElements(), "Text elements should be added at the front when this > other");

    // Bounding box updated accordingly
    assertEquals(10f, mergedHigher.getTop(), 0.0001f);
    assertEquals(5f, mergedHigher.getLeft(), 0.0001f);
    assertEquals(55f, mergedHigher.getWidth(), 0.0001f); // max(10+50=60, 5+30=35)-5=55
    assertEquals(60f, mergedHigher.getHeight(), 0.0001f); // max(20+50=70,10+40=50)-10=60
}
}
