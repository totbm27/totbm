// original test path: /Users/curtis/Github/Thesis/chatTester/Repos/Zappos_zappos-json/src/test/java/com/zappos/json/ZapposJson_ESTest.java
/*
 * This file was automatically generated by EvoSuite
 * Thu Jan 25 14:19:12 GMT 2024
 */
package com.zappos.json;








import java.math.BigInteger;
import java.math.BigDecimal;
import java.time.LocalDate;
import java.util.Map;
import java.util.List;
import java.util.*;
import java.lang.*;
import org.junit.Test;
import static org.junit.Assert.*;
import static org.evosuite.runtime.EvoAssertions.*;
import com.zappos.json.JsonConfig;
import com.zappos.json.ZapposJson;
import com.zappos.json.format.JavaDateFormatter;
import com.zappos.json.format.ValueFormatter;
import java.io.File;
import java.io.PipedReader;
import java.io.Reader;
import java.io.StringReader;
import java.io.Writer;
import java.lang.reflect.Array;
import java.sql.Timestamp;
import java.time.Instant;
import java.time.chrono.HijrahEra;
import java.util.Date;
import java.util.Locale;
import org.evosuite.runtime.EvoRunner;
import org.evosuite.runtime.EvoRunnerParameters;
import org.evosuite.runtime.mock.java.io.MockFile;
import org.evosuite.runtime.mock.java.io.MockPrintWriter;
import org.evosuite.runtime.mock.java.time.MockInstant;
import org.junit.runner.RunWith;

@RunWith(EvoRunner.class)
@EvoRunnerParameters(mockJVMNonDeterminism = true, useVFS = true, useVNET = true, resetStaticState = true, separateClassLoader = false)
public class ZapposJson_ESTest extends ZapposJson_ESTest_scaffolding {

    
    
    
    

    
    
    
    @Test
    public void testFromJson_variousTypes() throws Exception {
        // Arrange:
        TestZapposJson json = new TestZapposJson();

        // Prepare Readers with JSON/text representation for different types:
        Reader booleanReader = new StringReader("true");
        Reader stringReader = new StringReader("\"hello\"");
        Reader charReader = new StringReader("\"c\"");
        Reader byteReader = new StringReader("123");
        Reader shortReader = new StringReader("12345");
        Reader intReader = new StringReader("123456");
        Reader longReader = new StringReader("123456789");
        Reader floatReader = new StringReader("12.34");
        Reader doubleReader = new StringReader("56.78");
        Reader enumReader = new StringReader("MONDAY");
        Reader bigIntegerReader = new StringReader("12345678901234567890");
        Reader bigDecimalReader = new StringReader("12345.67890");
        Reader dateReader = new StringReader("\"2024-06-01T00:00:00Z\"");

        // Custom enum for testing
        enum Day { MONDAY, TUESDAY }

        // Act & Assert:

        // Boolean
        Boolean boolResult = json.fromJson(booleanReader, Boolean.class);
        assertEquals(Boolean.TRUE, boolResult);

        // String
        String strResult = json.fromJson(stringReader, String.class);
        assertEquals("hello", strResult);

        // Character
        Character charResult = json.fromJson(charReader, Character.class);
        assertEquals(Character.valueOf('c'), charResult);

        // Byte
        Byte byteResult = json.fromJson(byteReader, Byte.class);
        assertEquals(Byte.valueOf((byte)123), byteResult);

        // Short
        Short shortResult = json.fromJson(shortReader, Short.class);
        assertEquals(Short.valueOf((short)12345), shortResult);

        // Integer
        Integer intResult = json.fromJson(intReader, Integer.class);
        assertEquals(Integer.valueOf(123456), intResult);

        // Long
        Long longResult = json.fromJson(longReader, Long.class);
        assertEquals(Long.valueOf(123456789L), longResult);

        // Float
        Float floatResult = json.fromJson(floatReader, Float.class);
        assertEquals(Float.valueOf(12.34f), floatResult);

        // Double
        Double doubleResult = json.fromJson(doubleReader, Double.class);
        assertEquals(Double.valueOf(56.78), doubleResult);

        // Enum
        Day dayResult = json.fromJson(enumReader, Day.class);
        assertEquals(Day.MONDAY, dayResult);

        // BigInteger (uses formatter)
        BigInteger biResult = json.fromJson(bigIntegerReader, BigInteger.class);
        // As the formatter is added, it should parse as BigInteger, but we don't know the formatter impl.
        // So just check non-null and equals to the expected BigInteger string value.
        assertNotNull(biResult);
        assertEquals(new BigInteger("12345678901234567890"), biResult);

        // BigDecimal (uses formatter)
        BigDecimal bdResult = json.fromJson(bigDecimalReader, BigDecimal.class);
        assertNotNull(bdResult);
        assertEquals(new BigDecimal("12345.67890"), bdResult);

        // Date (uses formatter)
        // Since Date formatter implementation is unknown, we test that it does not throw and returns non-null.
        Date dateResult = json.fromJson(dateReader, Date.class);
        assertNotNull(dateResult);

        // Unsupported Iterable type - expect IllegalArgumentException
        Reader iterableReader = new StringReader("[]");
        Exception iterableEx = assertThrows(IllegalArgumentException.class, () -> {
            json.fromJson(iterableReader, java.util.List.class);
        });
        assertTrue(iterableEx.getMessage().contains("not support yet"));

        // Unsupported Array type - expect IllegalArgumentException
        Reader arrayReader = new StringReader("[]");
        Exception arrayEx = assertThrows(IllegalArgumentException.class, () -> {
            json.fromJson(arrayReader, String[].class);
        });
        assertTrue(arrayEx.getMessage().contains("not support yet"));

        // Unsupported Number type (e.g., custom subclass of Number) - expect IllegalArgumentException
        Reader unsupportedNumberReader = new StringReader("1");
        class CustomNumber extends Number {
            private static final long serialVersionUID = 1L;
            public int intValue() { return 0; }
            public long longValue() { return 0L; }
            public float floatValue() { return 0f; }
            public double doubleValue() { return 0d; }
        }
        Exception unsupportedNumberEx = assertThrows(IllegalArgumentException.class, () -> {
            json.fromJson(unsupportedNumberReader, CustomNumber.class);
        });
        assertTrue(unsupportedNumberEx.getMessage().contains("unsupported type"));

        // Invalid string (missing quotes) - expect IllegalArgumentException
        Reader invalidStringReader = new StringReader("hello");
        Exception invalidStringEx = assertThrows(IllegalArgumentException.class, () -> {
            json.fromJson(invalidStringReader, String.class);
        });
        assertTrue(invalidStringEx.getMessage().contains("Invalid string"));

        // Invalid char (string length != 1) - expect IllegalArgumentException
        Reader invalidCharReader = new StringReader("\"ab\"");
        Exception invalidCharEx = assertThrows(IllegalArgumentException.class, () -> {
            json.fromJson(invalidCharReader, Character.class);
        });
        assertTrue(invalidCharEx.getMessage().contains("Invalid character"));
    }
}
