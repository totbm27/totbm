// original test path: /Users/curtis/Github/Thesis/chatTester/Repos/tabulapdf_tabula-java/src/test/java/technology/tabula/extractors/BasicExtractionAlgorithm_ESTest.java
/*
 * This file was automatically generated by EvoSuite
 * Sat Feb 10 09:49:38 GMT 2024
 */
package technology.tabula.extractors;

import org.junit.Test;
import static org.junit.Assert.*;
import static org.evosuite.runtime.EvoAssertions.*;
import java.util.LinkedList;
import java.util.List;
import org.evosuite.runtime.EvoRunner;
import org.evosuite.runtime.EvoRunnerParameters;
import org.junit.runner.RunWith;
import technology.tabula.Line;
import technology.tabula.Page;
import technology.tabula.Ruling;
import technology.tabula.TextChunk;
import technology.tabula.extractors.BasicExtractionAlgorithm;

@RunWith(EvoRunner.class)
@EvoRunnerParameters(mockJVMNonDeterminism = true, useVFS = true, useVNET = true, resetStaticState = true, separateClassLoader = false)
public class BasicExtractionAlgorithm_ESTest extends BasicExtractionAlgorithm_ESTest_scaffolding {
@Test
public void testColumnPositions_MultiLineWithOverlapsAndWhitespace() {
    // Helper class to create TextChunk with given coordinates and text
    class TestTextChunk extends technology.tabula.TextChunk {
        TestTextChunk(String text, float left, float top, float right, float bottom) {
            super(text, left, top, right, bottom);
        }
    }

    // Create first line with spaced TextChunks forming initial columns
    List<technology.tabula.TextChunk> line1Chunks = new LinkedList<>();
    line1Chunks.add(new TestTextChunk("A", 0f, 0f, 10f, 10f));
    line1Chunks.add(new TestTextChunk("B", 20f, 0f, 30f, 10f));
    line1Chunks.add(new TestTextChunk("C", 40f, 0f, 50f, 10f));
    // Add a whitespace chunk that should be ignored
    line1Chunks.add(new TestTextChunk(" ", 60f, 0f, 70f, 10f));

    Line line1 = new Line(line1Chunks);

    // Second line with chunks overlapping first line's columns and one new column
    List<technology.tabula.TextChunk> line2Chunks = new LinkedList<>();
    // Overlaps first column (0-10)
    line2Chunks.add(new TestTextChunk("D", 5f, 10f, 15f, 20f));
    // Overlaps second column (20-30)
    line2Chunks.add(new TestTextChunk("E", 25f, 10f, 35f, 20f));
    // New column outside previous columns
    line2Chunks.add(new TestTextChunk("F", 60f, 10f, 70f, 20f));
    // Whitespace chunk to be ignored
    line2Chunks.add(new TestTextChunk("\t", 80f, 10f, 90f, 20f));

    Line line2 = new Line(line2Chunks);

    // Third line with no horizontal overlaps, should create new columns
    List<technology.tabula.TextChunk> line3Chunks = new LinkedList<>();
    line3Chunks.add(new TestTextChunk("G", 80f, 20f, 90f, 30f));
    line3Chunks.add(new TestTextChunk("H", 100f, 20f, 110f, 30f));

    Line line3 = new Line(line3Chunks);

    // Fourth line with only whitespace chunks, should be skipped entirely
    List<technology.tabula.TextChunk> line4Chunks = new LinkedList<>();
    line4Chunks.add(new TestTextChunk(" ", 0f, 30f, 10f, 40f));
    line4Chunks.add(new TestTextChunk("\n", 20f, 30f, 30f, 40f));
    Line line4 = new Line(line4Chunks);

    List<Line> lines = new LinkedList<>();
    lines.add(line1);
    lines.add(line2);
    lines.add(line3);
    lines.add(line4);

    List<Float> columnPositions = BasicExtractionAlgorithm.columnPositions(lines);

    // Expected columns:
    // 1) Merge of first line's first chunk (0-10) and second line's overlapping chunk (5-15) => right edge 15
    // 2) Merge of first line's second chunk (20-30) and second line's overlapping chunk (25-35) => right edge 35
    // 3) First line's third chunk (40-50) alone => right edge 50
    // 4) Second line's new column (60-70) => right edge 70
    // 5) Third line's new columns (80-90) and (100-110) => right edges 90 and 110
    // Whitespace chunks ignored

    List<Float> expected = new LinkedList<>();
    expected.add(15f);
    expected.add(35f);
    expected.add(50f);
    expected.add(70f);
    expected.add(90f);
    expected.add(110f);

    // Sort expected to match method output sorting
    expected.sort(Float::compare);

    org.junit.Assert.assertEquals("Column positions size mismatch", expected.size(), columnPositions.size());
    for (int i = 0; i < expected.size(); i++) {
        org.junit.Assert.assertEquals("Column position mismatch at index " + i, expected.get(i), columnPositions.get(i), 0.001f);
    }
}
}
