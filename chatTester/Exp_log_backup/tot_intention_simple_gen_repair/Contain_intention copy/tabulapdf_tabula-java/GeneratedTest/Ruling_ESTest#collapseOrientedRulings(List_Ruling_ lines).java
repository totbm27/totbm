// original test path: /Users/curtis/Github/Thesis/chatTester/Repos/tabulapdf_tabula-java/src/test/java/technology/tabula/Ruling_ESTest.java
/*
 * This file was automatically generated by EvoSuite
 * Sat Feb 10 10:09:27 GMT 2024
 */
package technology.tabula;

import org.junit.Test;
import static org.junit.Assert.*;
import static org.evosuite.runtime.EvoAssertions.*;
import java.awt.Point;
import java.awt.geom.Point2D;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import org.evosuite.runtime.EvoRunner;
import org.evosuite.runtime.EvoRunnerParameters;
import org.junit.runner.RunWith;
import technology.tabula.Ruling;

@RunWith(EvoRunner.class)
@EvoRunnerParameters(mockJVMNonDeterminism = true, useVFS = true, useVNET = true, resetStaticState = true, separateClassLoader = false)
public class Ruling_ESTest extends Ruling_ESTest_scaffolding {
@Test
public void testCollapseOrientedRulings() {
    // Create rulings that are exactly colinear and partially overlapping
    Ruling r1 = new Ruling(0f, 0f, 10f, 0f);  // horizontal line from (0,0) to (10,0)
    Ruling r2 = new Ruling(0f, 5f, 10f, 0f);  // horizontal line from (5,0) to (15,0), overlaps with r1 from 5 to 10

    // Create rulings that are nearly parallel and separated by distance <= pixel expand amount (1)
    Ruling r3 = new Ruling(1f, 0f, 10f, 0f);  // horizontal line from (0,1) to (10,1), 1 pixel below r1
    Ruling r4 = new Ruling(1f, 5f, 10f, 0f);  // horizontal line from (5,1) to (15,1), overlaps with r3

    // Create rulings that are parallel but separated by distance > pixel expand amount (1)
    Ruling r5 = new Ruling(3f, 0f, 10f, 0f);  // horizontal line from (0,3) to (10,3), 3 pixels below r1, should not merge

    // Create rulings with significantly different orientations (perpendicular lines)
    Ruling r6 = new Ruling(0f, 0f, 0f, 10f);  // vertical line from (0,0) to (0,10)
    Ruling r7 = new Ruling(5f, 0f, 0f, 10f);  // vertical line from (5,0) to (5,10)

    List<Ruling> input = new LinkedList<>();
    input.add(r1);
    input.add(r2);
    input.add(r3);
    input.add(r4);
    input.add(r5);
    input.add(r6);
    input.add(r7);

    List<Ruling> collapsed = Ruling.collapseOrientedRulings(input);

    // We expect:
    // - r1 and r2 merged into one horizontal ruling from (0,0) to (15,0)
    // - r3 and r4 merged into one horizontal ruling from (0,1) to (15,1)
    // - r5 remains separate (too far)
    // - r6 and r7 remain separate vertical rulings

    // Check the number of rulings after collapse
    // Expected: 5 rulings (2 merged horizontals + 1 separate horizontal + 2 verticals)
    org.junit.Assert.assertEquals(5, collapsed.size());

    // Helper to find rulings by orientation and position
    List<Ruling> horizontals = new LinkedList<>();
    List<Ruling> verticals = new LinkedList<>();
    for (Ruling r : collapsed) {
        if (r.horizontal()) {
            horizontals.add(r);
        } else if (r.vertical()) {
            verticals.add(r);
        }
    }

    // Check horizontal rulings count: 3 expected (merged r1+r2, merged r3+r4, r5)
    org.junit.Assert.assertEquals(3, horizontals.size());

    // Check vertical rulings count: 2 expected (r6, r7)
    org.junit.Assert.assertEquals(2, verticals.size());

    // Verify merged horizontal rulings span expected ranges
    boolean foundMergedTop0 = false;
    boolean foundMergedTop1 = false;
    boolean foundSeparateTop3 = false;
    for (Ruling h : horizontals) {
        float top = h.getTop();
        float left = h.getLeft();
        float right = h.getRight();

        if (Math.abs(top - 0f) < 0.01) {
            // merged r1 and r2: from 0 to 15 on x axis
            foundMergedTop0 = left <= 0f + 0.01 && right >= 15f - 0.01;
        } else if (Math.abs(top - 1f) < 0.01) {
            // merged r3 and r4: from 0 to 15 on x axis
            foundMergedTop1 = left <= 0f + 0.01 && right >= 15f - 0.01;
        } else if (Math.abs(top - 3f) < 0.01) {
            // separate r5: from 0 to 10 on x axis
            foundSeparateTop3 = left <= 0f + 0.01 && right >= 10f - 0.01;
        }
    }
    org.junit.Assert.assertTrue("Merged horizontal ruling at top=0 missing or incorrect", foundMergedTop0);
    org.junit.Assert.assertTrue("Merged horizontal ruling at top=1 missing or incorrect", foundMergedTop1);
    org.junit.Assert.assertTrue("Separate horizontal ruling at top=3 missing or incorrect", foundSeparateTop3);

    // Verify vertical rulings remain unchanged
    boolean foundV6 = false;
    boolean foundV7 = false;
    for (Ruling v : verticals) {
        float left = v.getLeft();
        float top = v.getTop();
        float bottom = v.getBottom();

        if (Math.abs(left - 0f) < 0.01) {
            // r6 vertical line from (0,0) to (0,10)
            foundV6 = top <= 0f + 0.01 && bottom >= 10f - 0.01;
        } else if (Math.abs(left - 5f) < 0.01) {
            // r7 vertical line from (5,0) to (5,10)
            foundV7 = top <= 0f + 0.01 && bottom >= 10f - 0.01;
        }
    }
    org.junit.Assert.assertTrue("Vertical ruling r6 missing or incorrect", foundV6);
    org.junit.Assert.assertTrue("Vertical ruling r7 missing or incorrect", foundV7);
}
}
