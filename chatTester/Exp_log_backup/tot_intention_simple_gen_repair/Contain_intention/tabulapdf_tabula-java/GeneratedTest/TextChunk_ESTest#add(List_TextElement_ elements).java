// original test path: /Users/curtis/Github/Thesis/chatTester/Repos/tabulapdf_tabula-java/src/test/java/technology/tabula/TextChunk_ESTest.java
/*
 * This file was automatically generated by EvoSuite
 * Sat Feb 10 10:15:23 GMT 2024
 */
package technology.tabula;

import org.junit.Test;
import static org.junit.Assert.*;
import static org.evosuite.runtime.EvoAssertions.*;
import java.awt.geom.Rectangle2D;
import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import org.evosuite.runtime.EvoRunner;
import org.evosuite.runtime.EvoRunnerParameters;
import org.junit.runner.RunWith;
import technology.tabula.Line;
import technology.tabula.Rectangle;
import technology.tabula.TextChunk;
import technology.tabula.TextElement;

@RunWith(EvoRunner.class)
@EvoRunnerParameters(mockJVMNonDeterminism = true, useVFS = true, useVNET = true, resetStaticState = true, separateClassLoader = false)
public class TextChunk_ESTest extends TextChunk_ESTest_scaffolding {
@Test
public void testAddListOfTextElements() {
    // Create initial TextElement and TextChunk
    TextElement initialElement = new TextElement("A", 10f, 20f, 5f, 7f);
    TextChunk chunk = new TextChunk(initialElement);

    // Create a list of additional TextElements with varied coordinates and dimensions
    List<TextElement> additionalElements = new ArrayList<>();
    additionalElements.add(new TextElement("B", 15f, 25f, 6f, 8f));
    additionalElements.add(new TextElement("C", 5f, 18f, 4f, 6f));
    additionalElements.add(new TextElement("D", 12f, 22f, 5f, 7f));

    // Add the list of TextElements to the TextChunk
    chunk.add(additionalElements);

    // Since internal collection is not accessible, verify by splitting the text and checking text content
    // The expected text is concatenation of all TextElements' text in order added: "A", "B", "C", "D"
    String expectedText = "ABCD";
    String actualText = chunk.getText(false).replaceAll("\\s+", ""); // remove any whitespace just in case

    // Assert that the text contains all added elements in order
    org.junit.Assert.assertEquals("TextChunk text should contain all added TextElements in order",
            expectedText, actualText);

    // Verify bounding box includes all elements by checking coordinates
    // The bounding box should cover min left, min top, max right, max bottom of all elements
    float minLeft = Math.min(Math.min(initialElement.x, 15f), Math.min(5f, 12f));
    float minTop = Math.min(Math.min(initialElement.y, 15f), Math.min(5f, 12f));
    float maxRight = Math.max(Math.max(initialElement.x + initialElement.width, 25f + 6f),
            Math.max(18f + 4f, 22f + 5f));
    float maxBottom = Math.max(Math.max(initialElement.y + initialElement.height, 15f + 8f),
            Math.max(5f + 6f, 12f + 7f));

    // The TextChunk bounding box is defined by top, left, width, height
    // We can get these from the Rectangle2D bounds of the chunk (TextChunk extends Rectangle)
    Rectangle2D bounds = chunk.getBounds2D();

    org.junit.Assert.assertTrue("Bounding box left should be <= min left of all elements",
            bounds.getX() <= minLeft + 0.001);
    org.junit.Assert.assertTrue("Bounding box top should be <= min top of all elements",
            bounds.getY() <= minTop + 0.001);
    org.junit.Assert.assertTrue("Bounding box right should be >= max right of all elements",
            bounds.getX() + bounds.getWidth() >= maxRight - 0.001);
    org.junit.Assert.assertTrue("Bounding box bottom should be >= max bottom of all elements",
            bounds.getY() + bounds.getHeight() >= maxBottom - 0.001);
}
}
