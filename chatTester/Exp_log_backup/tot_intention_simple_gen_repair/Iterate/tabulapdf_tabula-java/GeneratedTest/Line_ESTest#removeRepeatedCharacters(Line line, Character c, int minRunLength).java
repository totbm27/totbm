// original test path: /Users/curtis/Github/Thesis/chatTester/Repos/tabulapdf_tabula-java/src/test/java/technology/tabula/Line_ESTest.java
/*
 * This file was automatically generated by EvoSuite
 * Sat Feb 10 09:53:47 GMT 2024
 */
package technology.tabula;

import org.junit.Test;
import static org.junit.Assert.*;
import static org.evosuite.runtime.EvoAssertions.*;
import java.util.List;
import org.evosuite.runtime.EvoRunner;
import org.evosuite.runtime.EvoRunnerParameters;
import org.junit.runner.RunWith;
import technology.tabula.Line;
import technology.tabula.TextChunk;

@RunWith(EvoRunner.class)
@EvoRunnerParameters(mockJVMNonDeterminism = true, useVFS = true, useVNET = true, resetStaticState = true, separateClassLoader = false)
public class Line_ESTest extends Line_ESTest_scaffolding {
@Test
public void testRemoveRepeatedCharacters() {
    // Prepare TextChunks with varied text
    TextChunk chunk1 = new TextChunk("aaabbccccdd");
    TextChunk chunk2 = new TextChunk("eefff");
    TextChunk chunk3 = new TextChunk("ccc");
    TextChunk chunk4 = new TextChunk("cc");
    TextChunk chunk5 = new TextChunk("xyz");

    // Create a Line and add these chunks
    Line line = new Line();
    line.addTextChunk(chunk1);
    line.addTextChunk(chunk2);
    line.addTextChunk(chunk3);
    line.addTextChunk(chunk4);
    line.addTextChunk(chunk5);

    // Call the method under test
    Character targetChar = 'c';
    int minRunLength = 3;
    Line result = Line.removeRepeatedCharacters(line, targetChar, minRunLength);

    // Extract the resulting text chunks
    List<TextChunk> resultChunks = result.getTextElements();

    // We expect the following transformations:
    // "aaabbccccdd" -> "aaabbdd" (cccc squeezed/removed)
    // "eefff" -> unchanged
    // "ccc" -> squeezed/removed (empty or removed)
    // "cc" -> unchanged (run length < 3)
    // "xyz" -> unchanged

    // Collect texts from result chunks for easier assertions
    List<String> texts = new ArrayList<>();
    for (TextChunk tc : resultChunks) {
        texts.add(tc.getText());
    }

    // Assertions:
    // 1) "aaabbccccdd" chunk: "cccc" run removed/squeezed, so expect "aaabbdd"
    // Because squeeze returns a list of TextChunks, the original chunk may be split.
    // So we check that concatenating all chunks that came from chunk1 equals "aaabbdd"
    // Similarly for chunk3 "ccc" squeezed out, so it may be removed or replaced by empty chunks.
    // We verify the overall concatenation of all chunks equals expected combined string:
    // "aaabbdd" + "eefff" + "" (from "ccc") + "cc" + "xyz"
    // Since "ccc" squeezed out, it might be removed, so no empty chunk expected.
    // So final concatenation should be "aaabbddeefffccxyz"

    StringBuilder combined = new StringBuilder();
    for (String s : texts) {
        combined.append(s);
    }
    String combinedText = combined.toString();

    // Expected combined text after squeezing 'c' runs >= 3:
    // "aaabbdd" + "eefff" + "cc" + "xyz"
    // Note: "ccc" chunk squeezed out completely, so no text from it.
    String expected = "aaabbddeefffccxyz";

    org.junit.Assert.assertEquals(expected, combinedText);

    // Additional checks: 
    // The chunk with "cc" remains unchanged
    boolean foundCC = false;
    for (String s : texts) {
        if (s.equals("cc")) {
            foundCC = true;
            break;
        }
    }
    org.junit.Assert.assertTrue("Chunk with 'cc' should remain unchanged", foundCC);

    // The chunk with "ccc" should be removed or squeezed out, so no chunk equals "ccc"
    boolean foundCCC = false;
    for (String s : texts) {
        if (s.equals("ccc")) {
            foundCCC = true;
            break;
        }
    }
    org.junit.Assert.assertFalse("Chunk with 'ccc' should be squeezed out", foundCCC);
}
}
