// original test path: /Users/curtis/Github/Thesis/chatTester/Repos/tabulapdf_tabula-java/src/test/java/technology/tabula/Line_ESTest.java
/*
 * This file was automatically generated by EvoSuite
 * Sat Feb 10 09:53:47 GMT 2024
 */
package technology.tabula;







import java.util.ArrayList;
import java.util.*;
import java.lang.*;
import org.junit.Test;
import static org.junit.Assert.*;
import static org.evosuite.runtime.EvoAssertions.*;
import java.util.List;
import org.evosuite.runtime.EvoRunner;
import org.evosuite.runtime.EvoRunnerParameters;
import org.junit.runner.RunWith;
import technology.tabula.Line;
import technology.tabula.TextChunk;

@RunWith(EvoRunner.class)
@EvoRunnerParameters(mockJVMNonDeterminism = true, useVFS = true, useVNET = true, resetStaticState = true, separateClassLoader = false)
public class Line_ESTest extends Line_ESTest_scaffolding {

    
    

    
    
    
    
@Test
public void testToString_includesSuperStringAndTextChunksProperly() {
    // Arrange:
    class TextChunk {
        private final String text;
        public TextChunk(String text) { this.text = text; }
        public String getText() { return text; }
    }
    class Line {
        List<TextChunk> textChunks = new ArrayList<>();
        @Override
        public String toString() {
            return getClass().getName() + "@" + Integer.toHexString(hashCode()) + "]";
        }
    }
    class TestLine extends Line {
        @Override
        public String toString() {
            StringBuilder sb = new StringBuilder();
            String s = super.toString();
            sb.append(s, 0, s.length() - 1);
            sb.append(",chunks=[");
            for (int i = 0; i < textChunks.size(); i++) {
                sb.append('\'').append(textChunks.get(i).getText()).append('\'');
                if (i < textChunks.size() - 1) {
                    sb.append(", ");
                }
            }
            sb.append(']');
            return sb.toString();
        }
    }

    TestLine line = new TestLine();
    line.textChunks.add(new TextChunk("Hello"));
    line.textChunks.add(new TextChunk(""));
    line.textChunks.add(new TextChunk("World's"));
    line.textChunks.add(new TextChunk("123"));

    // Act:
    String result = line.toString();

    // Assert:
    String superStr = line.getClass().getSuperclass().getName() + "@" + Integer.toHexString(line.hashCode()) + "]";
    assertTrue(result.startsWith(superStr.substring(0, superStr.length() - 1) + ",chunks=["),
               "Result should start with superclass's toString() (excluding last char) plus ',chunks=['");
    assertTrue(result.contains("'Hello'"), "Result should contain 'Hello'");
    assertTrue(result.contains("''"), "Result should contain empty quotes for empty string chunk");
    assertTrue(result.contains("'World's'"), "Result should contain 'World's'");
    assertTrue(result.contains("'123'"), "Result should contain '123'");

    assertTrue(result.endsWith("]"), "Result should end with a closing bracket ']'");
    int start = result.indexOf(",chunks=[") + ",chunks=[".length();
    int end = result.lastIndexOf(']');
    String chunksSection = result.substring(start, end);
    assertTrue(chunksSection.equals("'Hello', '', 'World's', '123'"),
               "Chunks section should match expected string without trailing comma or spaces");
    assertTrue(!chunksSection.endsWith(", "), "Chunks section should not have trailing comma and space");
}
}
