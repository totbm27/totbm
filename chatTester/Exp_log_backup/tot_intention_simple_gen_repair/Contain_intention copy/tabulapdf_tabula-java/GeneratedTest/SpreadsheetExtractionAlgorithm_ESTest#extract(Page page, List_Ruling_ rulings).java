// original test path: /Users/curtis/Github/Thesis/chatTester/Repos/tabulapdf_tabula-java/src/test/java/technology/tabula/extractors/SpreadsheetExtractionAlgorithm_ESTest.java
/*
 * This file was automatically generated by EvoSuite
 * Sat Feb 10 09:51:32 GMT 2024
 */
package technology.tabula.extractors;

import org.junit.Test;
import static org.junit.Assert.*;
import static org.evosuite.runtime.EvoAssertions.*;
import java.util.LinkedList;
import java.util.List;
import org.evosuite.runtime.EvoRunner;
import org.evosuite.runtime.EvoRunnerParameters;
import org.junit.runner.RunWith;
import technology.tabula.Cell;
import technology.tabula.Page;
import technology.tabula.Rectangle;
import technology.tabula.Ruling;
import technology.tabula.extractors.SpreadsheetExtractionAlgorithm;

@RunWith(EvoRunner.class)
@EvoRunnerParameters(mockJVMNonDeterminism = true, useVFS = true, useVNET = true, resetStaticState = true, separateClassLoader = false)
public class SpreadsheetExtractionAlgorithm_ESTest extends SpreadsheetExtractionAlgorithm_ESTest_scaffolding {
@Test
public void testExtract_MultipleDistinctSpreadsheets() {
    // Setup a mock Page with text arranged in two distinct spreadsheet-like grids
    Page page = new Page(0, 0, 500, 500, 1);

    // Create horizontal rulings for two grids (some overlapping lines)
    List<Ruling> horizontalRulings = new LinkedList<>();
    // Grid 1 horizontal lines (y=50, 100, 150)
    horizontalRulings.add(new Ruling(10, 50, 200, 50));
    horizontalRulings.add(new Ruling(10, 100, 200, 100));
    horizontalRulings.add(new Ruling(10, 150, 200, 150));
    // Grid 2 horizontal lines (y=300, 350, 400)
    horizontalRulings.add(new Ruling(250, 300, 450, 300));
    horizontalRulings.add(new Ruling(250, 350, 450, 350));
    horizontalRulings.add(new Ruling(250, 400, 450, 400));
    // Add a nearly overlapping horizontal line to test collapsing (y=100.5)
    horizontalRulings.add(new Ruling(10, 100.5, 200, 100.5));

    // Create vertical rulings for two grids (some overlapping lines)
    List<Ruling> verticalRulings = new LinkedList<>();
    // Grid 1 vertical lines (x=10, 60, 110, 160, 200)
    verticalRulings.add(new Ruling(10, 50, 10, 150));
    verticalRulings.add(new Ruling(60, 50, 60, 150));
    verticalRulings.add(new Ruling(110, 50, 110, 150));
    verticalRulings.add(new Ruling(160, 50, 160, 150));
    verticalRulings.add(new Ruling(200, 50, 200, 150));
    // Grid 2 vertical lines (x=250, 300, 350, 400, 450)
    verticalRulings.add(new Ruling(250, 300, 250, 400));
    verticalRulings.add(new Ruling(300, 300, 300, 400));
    verticalRulings.add(new Ruling(350, 300, 350, 400));
    verticalRulings.add(new Ruling(400, 300, 400, 400));
    verticalRulings.add(new Ruling(450, 300, 450, 400));
    // Add a nearly overlapping vertical line to test collapsing (x=60.3)
    verticalRulings.add(new Ruling(60.3, 50, 60.3, 150));

    // Combine all rulings
    List<Ruling> rulings = new LinkedList<>();
    rulings.addAll(horizontalRulings);
    rulings.addAll(verticalRulings);

    // Add text elements to the page for each cell in both grids
    // For simplicity, we simulate text elements by overriding getText(Rectangle) in a subclass
    Page pageWithText = new Page(page.getWidth(), page.getHeight(), page.getRotation(), page.getPageNumber()) {
        @Override
        public List<TextElement> getText(Rectangle rect) {
            // Determine which grid the rect belongs to by position
            if (rect.getY() >= 50 && rect.getY() < 150 && rect.getX() >= 10 && rect.getX() < 200) {
                // Grid 1 cells: text "G1-R{row}C{col}"
                int row = (int) ((rect.getY() - 50) / 50);
                int col = (int) ((rect.getX() - 10) / 50);
                String text = "G1-R" + row + "C" + col;
                return TextElement.fromString(text);
            } else if (rect.getY() >= 300 && rect.getY() < 400 && rect.getX() >= 250 && rect.getX() < 450) {
                // Grid 2 cells: text "G2-R{row}C{col}"
                int row = (int) ((rect.getY() - 300) / 50);
                int col = (int) ((rect.getX() - 250) / 50);
                String text = "G2-R" + row + "C" + col;
                return TextElement.fromString(text);
            }
            return new LinkedList<>();
        }
    };

    SpreadsheetExtractionAlgorithm sea = new SpreadsheetExtractionAlgorithm();

    // Call the method under test
    List<Table> tables = sea.extract(pageWithText, rulings);

    // Assertions
    // Expect exactly two tables
    org.junit.Assert.assertEquals(2, tables.size());

    Table table1 = tables.get(0);
    Table table2 = tables.get(1);

    // Verify bounding rectangles cover the expected areas
    Rectangle expectedArea1 = new Rectangle(10, 50, 190, 100); // width=200-10, height=150-50
    Rectangle expectedArea2 = new Rectangle(250, 300, 200, 100); // width=450-250, height=400-300

    org.junit.Assert.assertTrue(expectedArea1.contains(table1.getBounds()) || table1.getBounds().contains(expectedArea1));
    org.junit.Assert.assertTrue(expectedArea2.contains(table2.getBounds()) || table2.getBounds().contains(expectedArea2));

    // Verify cells are correctly formed and text is assigned
    for (Table table : tables) {
        List<Cell> cells = table.getCells();
        org.junit.Assert.assertFalse(cells.isEmpty());

        for (Cell cell : cells) {
            String cellText = cell.getText();
            org.junit.Assert.assertNotNull(cellText);
            org.junit.Assert.assertFalse(cellText.trim().isEmpty());

            // Check that text matches expected pattern for either grid
            boolean matchesGrid1 = cellText.matches("G1-R\\dC\\d");
            boolean matchesGrid2 = cellText.matches("G2-R\\dC\\d");
            org.junit.Assert.assertTrue(matchesGrid1 || matchesGrid2);
        }
    }

    // Verify rulings assigned to each table correspond to their grid
    TableWithRulingLines t1 = (TableWithRulingLines) table1;
    TableWithRulingLines t2 = (TableWithRulingLines) table2;

    for (Ruling hr : t1.getHorizontalRulings()) {
        org.junit.Assert.assertTrue(hr.getY1() >= 50 && hr.getY1() <= 150);
    }
    for (Ruling vr : t1.getVerticalRulings()) {
        org.junit.Assert.assertTrue(vr.getX1() >= 10 && vr.getX1() <= 200);
    }
    for (Ruling hr : t2.getHorizontalRulings()) {
        org.junit.Assert.assertTrue(hr.getY1() >= 300 && hr.getY1() <= 400);
    }
    for (Ruling vr : t2.getVerticalRulings()) {
        org.junit.Assert.assertTrue(vr.getX1() >= 250 && vr.getX1() <= 450);
    }
}
}
