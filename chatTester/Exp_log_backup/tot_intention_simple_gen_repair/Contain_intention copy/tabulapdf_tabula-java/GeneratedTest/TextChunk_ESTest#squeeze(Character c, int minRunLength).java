// original test path: /Users/curtis/Github/Thesis/chatTester/Repos/tabulapdf_tabula-java/src/test/java/technology/tabula/TextChunk_ESTest.java
/*
 * This file was automatically generated by EvoSuite
 * Sat Feb 10 10:15:23 GMT 2024
 */
package technology.tabula;

import org.junit.Test;
import static org.junit.Assert.*;
import static org.evosuite.runtime.EvoAssertions.*;
import java.awt.geom.Rectangle2D;
import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import org.evosuite.runtime.EvoRunner;
import org.evosuite.runtime.EvoRunnerParameters;
import org.junit.runner.RunWith;
import technology.tabula.Line;
import technology.tabula.Rectangle;
import technology.tabula.TextChunk;
import technology.tabula.TextElement;

@RunWith(EvoRunner.class)
@EvoRunnerParameters(mockJVMNonDeterminism = true, useVFS = true, useVNET = true, resetStaticState = true, separateClassLoader = false)
public class TextChunk_ESTest extends TextChunk_ESTest_scaffolding {
@Test
public void testSqueeze() {
    // Helper to create TextElements with given texts
    class TE extends TextElement {
        private final String text;
        TE(String text) {
            super(0,0,0,0);
            this.text = text;
        }
        @Override
        public String getText() {
            return text;
        }
    }

    // Utility to count total TextElements in list of TextChunks
    java.util.function.Function<List<TextChunk>, Integer> countElements = chunks -> 
        chunks.stream().mapToInt(tc -> tc.getTextElements().size()).sum();

    // 1) Run of 'a' at start: ["a", "a", "a", "b", "c", "c", "c", "c", "d"]
    List<TextElement> elems1 = List.of(
        new TE("a"), new TE("a"), new TE("a"),
        new TE("b"),
        new TE("c"), new TE("c"), new TE("c"), new TE("c"),
        new TE("d")
    );
    TextChunk chunk1 = new TextChunk(elems1);
    List<TextChunk> result1 = chunk1.squeeze('a', 3);
    // Expect first run of 'a' isolated, rest squeezed recursively
    // So result1 should contain at least one chunk with 3 'a's and others
    boolean foundRunA = result1.stream().anyMatch(tc -> {
        String txt = tc.getText(false);
        return txt.chars().allMatch(ch -> ch == 'a') && txt.length() >= 3;
    });
    // Total elements preserved
    int totalElems1 = countElements.apply(result1);
    org.junit.Assert.assertTrue(foundRunA);
    org.junit.Assert.assertEquals(elems1.size(), totalElems1);

    // 2) Run of 'a' in middle: ["b", "a", "a", "a", "c", "d"]
    List<TextElement> elems2 = List.of(
        new TE("b"),
        new TE("a"), new TE("a"), new TE("a"),
        new TE("c"),
        new TE("d")
    );
    TextChunk chunk2 = new TextChunk(elems2);
    List<TextChunk> result2 = chunk2.squeeze('a', 3);
    boolean foundRunA2 = result2.stream().anyMatch(tc -> {
        String txt = tc.getText(false);
        return txt.chars().allMatch(ch -> ch == 'a') && txt.length() >= 3;
    });
    int totalElems2 = countElements.apply(result2);
    org.junit.Assert.assertTrue(foundRunA2);
    org.junit.Assert.assertEquals(elems2.size(), totalElems2);

    // 3) Run of 'a' at end: ["b", "c", "d", "a", "a", "a"]
    List<TextElement> elems3 = List.of(
        new TE("b"),
        new TE("c"),
        new TE("d"),
        new TE("a"), new TE("a"), new TE("a")
    );
    TextChunk chunk3 = new TextChunk(elems3);
    List<TextChunk> result3 = chunk3.squeeze('a', 3);
    boolean foundRunA3 = result3.stream().anyMatch(tc -> {
        String txt = tc.getText(false);
        return txt.chars().allMatch(ch -> ch == 'a') && txt.length() >= 3;
    });
    int totalElems3 = countElements.apply(result3);
    org.junit.Assert.assertTrue(foundRunA3);
    org.junit.Assert.assertEquals(elems3.size(), totalElems3);

    // 4) No runs meeting minRunLength: ["a", "b", "a", "c", "a"], minRunLength=2
    List<TextElement> elems4 = List.of(
        new TE("a"),
        new TE("b"),
        new TE("a"),
        new TE("c"),
        new TE("a")
    );
    TextChunk chunk4 = new TextChunk(elems4);
    List<TextChunk> result4 = chunk4.squeeze('a', 2);
    // Should return original chunk as single element list
    org.junit.Assert.assertEquals(1, result4.size());
    org.junit.Assert.assertEquals(chunk4, result4.get(0));
    int totalElems4 = countElements.apply(result4);
    org.junit.Assert.assertEquals(elems4.size(), totalElems4);

    // 5) Runs exactly equal to minRunLength: ["a", "a", "b", "b", "b"], c='b', minRunLength=3
    List<TextElement> elems5 = List.of(
        new TE("a"), new TE("a"),
        new TE("b"), new TE("b"), new TE("b")
    );
    TextChunk chunk5 = new TextChunk(elems5);
    List<TextChunk> result5 = chunk5.squeeze('b', 3);
    boolean foundRunB = result5.stream().anyMatch(tc -> {
        String txt = tc.getText(false);
        return txt.chars().allMatch(ch -> ch == 'b') && txt.length() == 3;
    });
    int totalElems5 = countElements.apply(result5);
    org.junit.Assert.assertTrue(foundRunB);
    org.junit.Assert.assertEquals(elems5.size(), totalElems5);

    // 6) Multi-character TextElements: ["aa", "a"], c='a', minRunLength=3
    List<TextElement> elems6 = List.of(
        new TE("aa"),
        new TE("a")
    );
    TextChunk chunk6 = new TextChunk(elems6);
    List<TextChunk> result6 = chunk6.squeeze('a', 3);
    // The first char of "aa" is 'a', so these count as consecutive 'a's
    // total length 2 elements, but minRunLength=3, so no split expected
    org.junit.Assert.assertEquals(1, result6.size());
    org.junit.Assert.assertEquals(chunk6, result6.get(0));
    int totalElems6 = countElements.apply(result6);
    org.junit.Assert.assertEquals(elems6.size(), totalElems6);
}
}
