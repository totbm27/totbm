// original test path: /Users/curtis/Github/Thesis/chatTester/Repos/tabulapdf_tabula-java/src/test/java/technology/tabula/TextChunk_ESTest.java
/*
 * This file was automatically generated by EvoSuite
 * Sat Feb 10 10:15:23 GMT 2024
 */
package technology.tabula;

import org.junit.Test;
import static org.junit.Assert.*;
import static org.evosuite.runtime.EvoAssertions.*;
import java.awt.geom.Rectangle2D;
import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import org.evosuite.runtime.EvoRunner;
import org.evosuite.runtime.EvoRunnerParameters;
import org.junit.runner.RunWith;
import technology.tabula.Line;
import technology.tabula.Rectangle;
import technology.tabula.TextChunk;
import technology.tabula.TextElement;

@RunWith(EvoRunner.class)
@EvoRunnerParameters(mockJVMNonDeterminism = true, useVFS = true, useVNET = true, resetStaticState = true, separateClassLoader = false)
public class TextChunk_ESTest extends TextChunk_ESTest_scaffolding {
@Test
public void testGroupByDirectionality() {
    // Create TextElements with different directionality characters
    // LTR chars: 'a', 'b', 'c' (DIRECTIONALITY_LEFT_TO_RIGHT)
    // RTL chars: Hebrew letter 'א' (U+05D0) (DIRECTIONALITY_RIGHT_TO_LEFT)
    // Whitespace char: ' ' (DIRECTIONALITY_WHITESPACE)
    TextElement te1 = new TextElement("a", 0, 0, 5, 10);
    TextElement te2 = new TextElement("b", 5, 0, 5, 10);
    TextElement te3 = new TextElement(" ", 10, 0, 5, 10);
    TextElement te4 = new TextElement("\u05D0", 15, 0, 5, 10); // Hebrew Alef
    TextElement te5 = new TextElement("\u05D1", 20, 0, 5, 10); // Hebrew Bet
    TextElement te6 = new TextElement("c", 25, 0, 5, 10);

    // Compose a TextChunk with mixed directionality elements
    List<TextElement> elements = new ArrayList<>();
    elements.add(te1);
    elements.add(te2);
    elements.add(te3);
    elements.add(te4);
    elements.add(te5);
    elements.add(te6);

    TextChunk chunk = new TextChunk(elements);

    // Test with LTR dominant = true
    TextChunk resultLtr = chunk.groupByDirectionality(true);
    String textLtr = resultLtr.getText(false);
    // Expected behavior:
    // - LTR group: "a", "b", " " (whitespace added at start of RTL group is not triggered here)
    // - RTL group: "א", "ב" reversed to "ב", "א"
    // - final order: LTR group + reversed RTL group + last "c"
    // But last "c" is LTR, so it should be grouped with first LTR group or separate?
    // According to method, "c" is different directionality from previous RTL group, so new group.
    // So groups: [a,b, ], [ב,א], [c]
    // Since isLtrDominant = true, chunks order not reversed.
    // So final text elements order: a b ' ' ב א c
    // But RTL group reversed internally: ב א
    // So final text: "ab באc"
    // Note: whitespace is added at start of RTL group only if whitespace directionality and buffDirectionality matches dominant direction.
    // Here whitespace is LTR and buffDirectionality is LTR, so whitespace stays at end of LTR group.

    // Let's build expected string:
    // te1: "a"
    // te2: "b"
    // te3: " "
    // te5: "ב" (reversed order)
    // te4: "א"
    // te6: "c"
    String expectedLtr = "ab באc";
    // Remove spaces for comparison because getText(false) returns concatenated text without line returns
    expectedLtr = expectedLtr.replace(" ", "");
    textLtr = textLtr.replace(" ", "");
    org.junit.Assert.assertEquals(expectedLtr, textLtr);

    // Test with LTR dominant = false (RTL dominant)
    TextChunk resultRtl = chunk.groupByDirectionality(false);
    String textRtl = resultRtl.getText(false);
    // Now chunks order reversed:
    // groups: [a,b, ], [ב,א], [c]
    // reversed order: [c], [ב,א], [a,b, ]
    // RTL groups reversed internally as before
    // So final text elements order: c ב א a b ' '
    // Expected string: "cבאab "
    String expectedRtl = "cבאab ";
    expectedRtl = expectedRtl.replace(" ", "");
    textRtl = textRtl.replace(" ", "");
    org.junit.Assert.assertEquals(expectedRtl, textRtl);

    // Test that exception is thrown if TextChunk has no elements
    TextChunk emptyChunk = new TextChunk(new ArrayList<>());
    try {
        emptyChunk.groupByDirectionality(true);
        org.junit.Assert.fail("Expected IllegalArgumentException for empty TextChunk");
    } catch (IllegalArgumentException e) {
        // expected
    }
}
}
