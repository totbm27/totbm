// original test path: /Users/curtis/Github/Thesis/chatTester/Repos/Zappos_zappos-json/src/test/java/com/zappos/json/format/JavaTimeInstantFormatter_ESTest.java
/*
 * This file was automatically generated by EvoSuite
 * Thu Jan 25 13:40:01 GMT 2024
 */
package com.zappos.json.format;

import org.junit.Test;
import static org.junit.Assert.*;
import static org.evosuite.runtime.EvoAssertions.*;
import com.zappos.json.ZapposJson;
import com.zappos.json.format.JavaTimeInstantFormatter;
import com.zappos.json.format.ValueFormatter;
import java.time.DateTimeException;
import java.time.Instant;
import java.time.format.DateTimeParseException;
import org.evosuite.runtime.EvoRunner;
import org.evosuite.runtime.EvoRunnerParameters;
import org.evosuite.runtime.mock.java.time.MockInstant;
import org.evosuite.runtime.mock.java.util.MockDate;
import org.junit.runner.RunWith;

@RunWith(EvoRunner.class)
@EvoRunnerParameters(mockJVMNonDeterminism = true, useVFS = true, useVNET = true, resetStaticState = true, separateClassLoader = false)
public class JavaTimeInstantFormatter_ESTest extends JavaTimeInstantFormatter_ESTest_scaffolding {
@Test
public void testParse() throws Exception {
    JavaTimeInstantFormatter formatter = new JavaTimeInstantFormatter();

    // Case 1: No formatter set, parse epoch millis string
    String epochMillisString = "1672531200000"; // corresponds to 2023-01-01T00:00:00Z
    Instant expectedInstant = Instant.ofEpochMilli(Long.parseLong(epochMillisString));
    Instant parsedInstant = formatter.parse(null, epochMillisString);
    org.junit.Assert.assertEquals(expectedInstant, parsedInstant);

    // Case 2: Formatter set - use ISO_INSTANT formatter
    java.time.format.DateTimeFormatter isoFormatter = java.time.format.DateTimeFormatter.ISO_INSTANT;
    // Use reflection to set the private formatter field since no setter is available
    java.lang.reflect.Field formatterField = JavaTimeInstantFormatter.class.getDeclaredField("formatter");
    formatterField.setAccessible(true);
    formatterField.set(formatter, isoFormatter);

    String isoInstantString = "2023-01-01T00:00:00Z";
    Instant expectedFromIso = Instant.parse(isoInstantString);
    Instant parsedFromIso = formatter.parse(null, isoInstantString);
    org.junit.Assert.assertEquals(expectedFromIso, parsedFromIso);

    // Case 3: Invalid string for epoch millis (no formatter)
    formatterField.set(formatter, null);
    String invalidEpochString = "notANumber";
    try {
        formatter.parse(null, invalidEpochString);
        org.junit.Assert.fail("Expected NumberFormatException");
    } catch (NumberFormatException e) {
        // expected
    }

    // Case 4: Invalid string for formatter parse
    formatterField.set(formatter, isoFormatter);
    String invalidIsoString = "invalid-date-time";
    try {
        formatter.parse(null, invalidIsoString);
        org.junit.Assert.fail("Expected DateTimeParseException");
    } catch (DateTimeParseException e) {
        // expected
    }
}
}
