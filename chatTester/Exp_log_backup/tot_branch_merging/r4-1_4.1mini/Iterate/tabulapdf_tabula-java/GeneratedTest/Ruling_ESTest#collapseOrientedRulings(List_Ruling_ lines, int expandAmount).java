// original test path: /Users/curtis/Github/Thesis/chatTester/Repos/tabulapdf_tabula-java/src/test/java/technology/tabula/Ruling_ESTest.java
/*
 * This file was automatically generated by EvoSuite
 * Sat Feb 10 10:09:27 GMT 2024
 */
package technology.tabula;

import org.junit.Test;
import static org.junit.Assert.*;
import static org.evosuite.runtime.EvoAssertions.*;
import java.awt.Point;
import java.awt.geom.Point2D;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import org.evosuite.runtime.EvoRunner;
import org.evosuite.runtime.EvoRunnerParameters;
import org.junit.runner.RunWith;
import technology.tabula.Ruling;

@RunWith(EvoRunner.class)
@EvoRunnerParameters(mockJVMNonDeterminism = true, useVFS = true, useVNET = true, resetStaticState = true, separateClassLoader = false)
public class Ruling_ESTest extends Ruling_ESTest_scaffolding {
@Test
public void testCollapseOrientedRulings() {
    List<Ruling> rulings = new LinkedList<>();

    // Create horizontal rulings that nearly overlap or are adjacent within expandAmount
    rulings.add(new Ruling(10f, 0f, 5f, 0f));  // from (0,10) to (5,10)
    rulings.add(new Ruling(10f, 4f, 5f, 0f));  // overlaps with above from (4,10) to (9,10)
    rulings.add(new Ruling(10f, 15f, 3f, 0f)); // separate ruling from (15,10) to (18,10)
    rulings.add(new Ruling(10f, 18.5f, 2f, 0f)); // adjacent within expandAmount to above (18.5,10) to (20.5,10)
    rulings.add(new Ruling(20f, 0f, 5f, 0f));  // different position (20,0) to (25,20) horizontal line at y=20

    // Create vertical rulings that nearly overlap or are adjacent within expandAmount
    rulings.add(new Ruling(0f, 30f, 0f, 5f));  // vertical from (30,0) to (30,5)
    rulings.add(new Ruling(4f, 30f, 0f, 5f));  // overlaps with above from (30,4) to (30,9)
    rulings.add(new Ruling(15f, 30f, 0f, 3f)); // separate vertical from (30,15) to (30,18)
    rulings.add(new Ruling(18.5f, 30f, 0f, 2f)); // adjacent within expandAmount to above (30,18.5) to (30,20.5)

    int expandAmount = 1;

    List<Ruling> collapsed = Ruling.collapseOrientedRulings(rulings, expandAmount);

    // We expect horizontal rulings at y=10 to be merged into two rulings:
    // one from 0 to 9 (merged first two), one from 15 to 20.5 (merged last two)
    // horizontal ruling at y=20 remains separate
    // vertical rulings at x=30 merged similarly into two rulings:
    // one from 0 to 9, one from 15 to 20.5

    // Count horizontal rulings at y=10
    long horizontalAt10 = collapsed.stream()
            .filter(r -> r.horizontal() && Math.abs(r.getPosition() - 10f) < 0.001f)
            .count();
    // Count horizontal rulings at y=20
    long horizontalAt20 = collapsed.stream()
            .filter(r -> r.horizontal() && Math.abs(r.getPosition() - 20f) < 0.001f)
            .count();
    // Count vertical rulings at x=30
    long verticalAt30 = collapsed.stream()
            .filter(r -> r.vertical() && Math.abs(r.getPosition() - 30f) < 0.001f)
            .count();

    // Check that zero-length rulings are excluded
    boolean hasZeroLength = collapsed.stream().anyMatch(r -> r.length() == 0);

    // Assertions
    org.junit.Assert.assertEquals(2, horizontalAt10);
    org.junit.Assert.assertEquals(1, horizontalAt20);
    org.junit.Assert.assertEquals(2, verticalAt30);
    org.junit.Assert.assertFalse(hasZeroLength);

    // Further check merged ranges for horizontal at y=10
    for (Ruling r : collapsed) {
        if (r.horizontal() && Math.abs(r.getPosition() - 10f) < 0.001f) {
            float start = r.getStart();
            float end = r.getEnd();
            // Should cover either [0,9] or [15,20.5]
            boolean coversFirst = start <= 0f + 0.001f && end >= 9f - 0.001f;
            boolean coversSecond = start <= 15f + 0.001f && end >= 20.5f - 0.001f;
            org.junit.Assert.assertTrue(coversFirst || coversSecond);
        }
    }

    // Further check merged ranges for vertical at x=30
    for (Ruling r : collapsed) {
        if (r.vertical() && Math.abs(r.getPosition() - 30f) < 0.001f) {
            float start = r.getStart();
            float end = r.getEnd();
            // Should cover either [0,9] or [15,20.5]
            boolean coversFirst = start <= 0f + 0.001f && end >= 9f - 0.001f;
            boolean coversSecond = start <= 15f + 0.001f && end >= 20.5f - 0.001f;
            org.junit.Assert.assertTrue(coversFirst || coversSecond);
        }
    }
}
}
