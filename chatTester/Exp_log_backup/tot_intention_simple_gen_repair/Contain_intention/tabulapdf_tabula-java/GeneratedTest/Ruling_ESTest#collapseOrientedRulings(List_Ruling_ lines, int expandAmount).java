// original test path: /Users/curtis/Github/Thesis/chatTester/Repos/tabulapdf_tabula-java/src/test/java/technology/tabula/Ruling_ESTest.java
/*
 * This file was automatically generated by EvoSuite
 * Sat Feb 10 10:09:27 GMT 2024
 */
package technology.tabula;

import org.junit.Test;
import static org.junit.Assert.*;
import static org.evosuite.runtime.EvoAssertions.*;
import java.awt.Point;
import java.awt.geom.Point2D;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import org.evosuite.runtime.EvoRunner;
import org.evosuite.runtime.EvoRunnerParameters;
import org.junit.runner.RunWith;
import technology.tabula.Ruling;

@RunWith(EvoRunner.class)
@EvoRunnerParameters(mockJVMNonDeterminism = true, useVFS = true, useVNET = true, resetStaticState = true, separateClassLoader = false)
public class Ruling_ESTest extends Ruling_ESTest_scaffolding {
@Test
public void testCollapseOrientedRulings() {
    // Helper to create horizontal ruling: top fixed, left=start, width=end-start, height=0
    // Helper to create vertical ruling: left fixed, top=start, width=0, height=end-start
    // Horizontal rulings at y=10, some overlapping or within 2 units
    Ruling h1 = new Ruling(10f, 0f, 5f, 0f);   // from x=0 to 5
    Ruling h2 = new Ruling(10f, 4f, 3f, 0f);   // from x=4 to 7, overlaps with h1 by 1 unit
    Ruling h3 = new Ruling(10f, 9f, 1f, 0f);   // from x=9 to 10, gap of 2 units from h2 end (7 to 9)
    Ruling h4 = new Ruling(10f, 12f, 2f, 0f);  // from x=12 to 14, gap > 2 units from h3 end (10 to 12)
    Ruling h5 = new Ruling(10f, 13f, 3f, 0f);  // from x=13 to 16, overlaps with h4 by 1 unit

    // Vertical rulings at x=20, with gaps > 2 units, so no merges expected
    Ruling v1 = new Ruling(0f, 20f, 0f, 3f);   // from y=0 to 3
    Ruling v2 = new Ruling(6f, 20f, 0f, 3f);   // from y=6 to 9, gap 3 units from v1 end (3 to 6)
    Ruling v3 = new Ruling(13f, 20f, 0f, 2f);  // from y=13 to 15, gap 4 units from v2 end (9 to 13)

    // Zero-length ruling (start == end)
    Ruling zeroLength = new Ruling(5f, 5f, 0f, 0f); // length 0

    // Opposite direction rulings at y=30, overlapping or nearly intersecting within expand margin
    // One from left=10 to 15, other from left=15 to 10 (reverse)
    Ruling opp1 = new Ruling(30f, 10f, 5f, 0f);  // left=10, right=15
    Ruling opp2 = new Ruling(30f, 15f, -5f, 0f); // left=15, right=10 (reverse direction)

    List<Ruling> horizontalRulings = new LinkedList<>();
    horizontalRulings.add(h1);
    horizontalRulings.add(h2);
    horizontalRulings.add(h3);
    horizontalRulings.add(h4);
    horizontalRulings.add(h5);
    horizontalRulings.add(zeroLength);
    horizontalRulings.add(opp1);
    horizontalRulings.add(opp2);

    List<Ruling> verticalRulings = new LinkedList<>();
    verticalRulings.add(v1);
    verticalRulings.add(v2);
    verticalRulings.add(v3);
    verticalRulings.add(zeroLength); // zero length vertical ruling

    int expandAmount = 2;

    // Test horizontal rulings collapse
    List<Ruling> collapsedHorizontals = Ruling.collapseOrientedRulings(horizontalRulings, expandAmount);

    // Expected:
    // h1 and h2 merged: from x=0 to 7 at y=10
    // h3 separate (gap exactly 2 units from h2 end, so merged with previous? expandAmount=2 allows merge)
    // h4 and h5 merged: from x=12 to 16 at y=10
    // zeroLength excluded
    // opp1 and opp2 merged into one from x=10 to 15 at y=30, direction normalized

    // Check no zero length rulings
    for (Ruling r : collapsedHorizontals) {
        assertTrue(r.length() > 0);
    }

    // Check merged rulings count: 
    // h1,h2,h3 merged into one because h3 is within 2 units gap from h2 end (7 to 9)
    // So first merged horizontal: x=0 to 10 at y=10 (h1,h2,h3)
    // h4,h5 merged: x=12 to 16 at y=10
    // opp1, opp2 merged: x=10 to 15 at y=30
    // So total 3 rulings expected
    assertEquals(3, collapsedHorizontals.size());

    // Validate merged intervals and positions
    boolean foundFirstGroup = false;
    boolean foundSecondGroup = false;
    boolean foundOppositeDirGroup = false;
    for (Ruling r : collapsedHorizontals) {
        assertFalse(r.oblique());
        if (Math.abs(r.getPosition() - 10f) < 0.01f) {
            // y=10 group
            float start = r.getStart();
            float end = r.getEnd();
            // Should be either 0-10 or 12-16
            if ((start <= 0.01f && end >= 9.99f) || (start <= 9.99f && end >= 0.01f)) {
                foundFirstGroup = true;
            } else if ((start <= 12.01f && end >= 15.99f) || (start <= 15.99f && end >= 12.01f)) {
                foundSecondGroup = true;
            } else {
                fail("Unexpected horizontal ruling interval at y=10: start=" + start + ", end=" + end);
            }
        } else if (Math.abs(r.getPosition() - 30f) < 0.01f) {
            // y=30 group (opposite direction merged)
            float start = r.getStart();
            float end = r.getEnd();
            assertTrue((start <= 10.01f && end >= 14.99f) || (start <= 14.99f && end >= 10.01f));
            foundOppositeDirGroup = true;
        } else {
            fail("Unexpected horizontal ruling position: " + r.getPosition());
        }
    }
    assertTrue(foundFirstGroup);
    assertTrue(foundSecondGroup);
    assertTrue(foundOppositeDirGroup);

    // Test vertical rulings collapse (should not merge due to gaps > 2)
    List<Ruling> collapsedVerticals = Ruling.collapseOrientedRulings(verticalRulings, expandAmount);

    // zeroLength excluded
    for (Ruling r : collapsedVerticals) {
        assertTrue(r.length() > 0);
    }

    // Should remain 3 separate rulings
    assertEquals(3, collapsedVerticals.size());

    // Positions all 20, but starts and ends distinct with gaps > 2
    float prevEnd = -Float.MAX_VALUE;
    for (Ruling r : collapsedVerticals) {
        assertEquals(20f, r.getPosition(), 0.01f);
        assertTrue(r.getStart() < r.getEnd());
        assertTrue(r.getStart() > prevEnd + expandAmount);
        prevEnd = r.getEnd();
    }
}
}
