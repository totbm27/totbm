// original test path: /Users/curtis/Github/Thesis/chatTester/Repos/tabulapdf_tabula-java/src/test/java/technology/tabula/extractors/SpreadsheetExtractionAlgorithm_ESTest.java
/*
 * This file was automatically generated by EvoSuite
 * Sat Feb 10 09:51:32 GMT 2024
 */
package technology.tabula.extractors;

import org.junit.Test;
import static org.junit.Assert.*;
import static org.evosuite.runtime.EvoAssertions.*;
import java.util.LinkedList;
import java.util.List;
import org.evosuite.runtime.EvoRunner;
import org.evosuite.runtime.EvoRunnerParameters;
import org.junit.runner.RunWith;
import technology.tabula.Cell;
import technology.tabula.Page;
import technology.tabula.Rectangle;
import technology.tabula.Ruling;
import technology.tabula.extractors.SpreadsheetExtractionAlgorithm;

@RunWith(EvoRunner.class)
@EvoRunnerParameters(mockJVMNonDeterminism = true, useVFS = true, useVNET = true, resetStaticState = true, separateClassLoader = false)
public class SpreadsheetExtractionAlgorithm_ESTest extends SpreadsheetExtractionAlgorithm_ESTest_scaffolding {
@Test
public void testFindSpreadsheetsFromCells() {
    // Helper to create Rectangle by top-left x,y and width,height
    // Note: Rectangle constructor: Rectangle(float top, float left, float width, float height)
    // top = y, left = x
    // So Rectangle(0,0,10,10) means top=0, left=0, width=10, height=10

    // 1) 3x3 grid of adjacent cells (each 10x10), no gaps or overlaps
    List<Rectangle> gridCells = new LinkedList<>();
    for (int row = 0; row < 3; row++) {
        for (int col = 0; col < 3; col++) {
            gridCells.add(new Rectangle(row * 10, col * 10, 10, 10));
        }
    }
    List<Rectangle> resultGrid = SpreadsheetExtractionAlgorithm.findSpreadsheetsFromCells(gridCells);
    // Expect a single rectangle bounding entire 3x3 grid: top=0, left=0, width=30, height=30
    assertEquals(1, resultGrid.size());
    Rectangle boundingGrid = resultGrid.get(0);
    assertEquals(0f, boundingGrid.getTop(), 0.001);
    assertEquals(0f, boundingGrid.getLeft(), 0.001);
    assertEquals(30f, boundingGrid.getWidth(), 0.001);
    assertEquals(30f, boundingGrid.getHeight(), 0.001);

    // 2) Overlapping cells: two rectangles overlapping partially
    List<Rectangle> overlappingCells = new LinkedList<>();
    overlappingCells.add(new Rectangle(0, 0, 20, 20));
    overlappingCells.add(new Rectangle(10, 10, 20, 20));
    List<Rectangle> resultOverlap = SpreadsheetExtractionAlgorithm.findSpreadsheetsFromCells(overlappingCells);
    // Expect a single rectangle bounding both: top=0, left=0, width=30, height=30
    assertEquals(1, resultOverlap.size());
    Rectangle boundingOverlap = resultOverlap.get(0);
    assertEquals(0f, boundingOverlap.getTop(), 0.001);
    assertEquals(0f, boundingOverlap.getLeft(), 0.001);
    assertEquals(30f, boundingOverlap.getWidth(), 0.001);
    assertEquals(30f, boundingOverlap.getHeight(), 0.001);

    // 3) Isolated cells scattered apart
    List<Rectangle> isolatedCells = new LinkedList<>();
    isolatedCells.add(new Rectangle(0, 0, 10, 10));
    isolatedCells.add(new Rectangle(50, 50, 10, 10));
    isolatedCells.add(new Rectangle(100, 100, 10, 10));
    List<Rectangle> resultIsolated = SpreadsheetExtractionAlgorithm.findSpreadsheetsFromCells(isolatedCells);
    // Expect 3 rectangles identical to input cells (no merging)
    assertEquals(3, resultIsolated.size());
    for (Rectangle r : isolatedCells) {
        boolean found = false;
        for (Rectangle res : resultIsolated) {
            if (Math.abs(r.getTop() - res.getTop()) < 0.001 &&
                Math.abs(r.getLeft() - res.getLeft()) < 0.001 &&
                Math.abs(r.getWidth() - res.getWidth()) < 0.001 &&
                Math.abs(r.getHeight() - res.getHeight()) < 0.001) {
                found = true;
                break;
            }
        }
        assertTrue("Isolated cell not found in result: " + r, found);
    }

    // 4) L-shaped cluster (non-rectangular shape)
    List<Rectangle> lShapeCells = new LinkedList<>();
    // vertical bar of L
    lShapeCells.add(new Rectangle(0, 0, 10, 10));
    lShapeCells.add(new Rectangle(10, 0, 10, 10));
    lShapeCells.add(new Rectangle(20, 0, 10, 10));
    // horizontal bar of L
    lShapeCells.add(new Rectangle(20, 10, 10, 10));
    lShapeCells.add(new Rectangle(20, 20, 10, 10));
    List<Rectangle> resultLShape = SpreadsheetExtractionAlgorithm.findSpreadsheetsFromCells(lShapeCells);
    // Expect a single rectangle bounding entire L shape: top=0, left=0, width=30, height=30
    assertEquals(1, resultLShape.size());
    Rectangle boundingL = resultLShape.get(0);
    assertEquals(0f, boundingL.getTop(), 0.001);
    assertEquals(0f, boundingL.getLeft(), 0.001);
    assertEquals(30f, boundingL.getWidth(), 0.001);
    assertEquals(30f, boundingL.getHeight(), 0.001);

    // 5) Duplicate Rectangle entries
    List<Rectangle> duplicateCells = new LinkedList<>();
    Rectangle dupRect = new Rectangle(0, 0, 10, 10);
    duplicateCells.add(dupRect);
    duplicateCells.add(dupRect);
    duplicateCells.add(new Rectangle(10, 0, 10, 10));
    duplicateCells.add(new Rectangle(10, 0, 10, 10));
    List<Rectangle> resultDuplicates = SpreadsheetExtractionAlgorithm.findSpreadsheetsFromCells(duplicateCells);
    // Expect a single rectangle bounding both unique cells: top=0, left=0, width=20, height=10
    assertEquals(1, resultDuplicates.size());
    Rectangle boundingDup = resultDuplicates.get(0);
    assertEquals(0f, boundingDup.getTop(), 0.001);
    assertEquals(0f, boundingDup.getLeft(), 0.001);
    assertEquals(20f, boundingDup.getWidth(), 0.001);
    assertEquals(10f, boundingDup.getHeight(), 0.001);

    // 6) Empty input list
    List<Rectangle> emptyCells = new LinkedList<>();
    List<Rectangle> resultEmpty = SpreadsheetExtractionAlgorithm.findSpreadsheetsFromCells(emptyCells);
    // Expect empty output list
    assertTrue(resultEmpty.isEmpty());
}
}
