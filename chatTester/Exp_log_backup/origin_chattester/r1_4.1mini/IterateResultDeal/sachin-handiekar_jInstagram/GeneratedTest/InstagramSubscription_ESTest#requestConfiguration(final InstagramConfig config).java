// original test path: /Users/curtis/Github/Thesis/chatTester/Repos/sachin-handiekar_jInstagram/src/test/java/org/jinstagram/realtime/InstagramSubscription_ESTest.java
/*
 * This file was automatically generated by EvoSuite
 * Sat Jan 27 04:59:46 GMT 2024
 */
package org.jinstagram.realtime;






import org.jinstagram.realtime.InstagramConfig;
import java.util.*;
import java.lang.*;
import org.junit.Test;
import static org.junit.Assert.*;
import org.jinstagram.InstagramConfig;
import org.junit.Test;
import static org.junit.Assert.*;
import static org.evosuite.runtime.EvoAssertions.*;
import org.evosuite.runtime.EvoRunner;
import org.evosuite.runtime.EvoRunnerParameters;
import org.jinstagram.InstagramConfig;
import org.jinstagram.realtime.InstagramSubscription;
import org.junit.runner.RunWith;

@RunWith(EvoRunner.class)
@EvoRunnerParameters(mockJVMNonDeterminism = true, useVFS = true, useVNET = true, resetStaticState = true, separateClassLoader = false)
public class InstagramSubscription_ESTest extends InstagramSubscription_ESTest_scaffolding {
    
    


    
    
    
    
    @Test
    public void testRequestConfiguration() {
        InstagramSubscription subscription = new InstagramSubscription();

        // Initial config should not be null
        InstagramConfig initialConfig = new InstagramConfig();
        subscription.requestConfiguration(initialConfig);
        // Since we cannot access the private config directly, we test by chaining and no exception

        // Test that method returns the same instance (method chaining)
        InstagramSubscription returned = subscription.requestConfiguration(new InstagramConfig());
        assertSame(subscription, returned, "requestConfiguration should return the same InstagramSubscription instance");

        // Test passing null does not change the config (no exception and returns same instance)
        InstagramSubscription returnedNull = subscription.requestConfiguration(null);
        assertSame(subscription, returnedNull, "requestConfiguration with null should return the same InstagramSubscription instance");

        // To verify config is updated, we can create a subclass to expose config or use reflection
        // Using reflection to verify the private config field is updated
        try {
            java.lang.reflect.Field configField = InstagramSubscription.class.getDeclaredField("config");
            configField.setAccessible(true);

            InstagramConfig configBefore = (InstagramConfig) configField.get(subscription);
            InstagramConfig newConfig = new InstagramConfig();
            subscription.requestConfiguration(newConfig);
            InstagramConfig configAfter = (InstagramConfig) configField.get(subscription);

            assertNotNull(configBefore, "Initial config should not be null");
            assertNotNull(configAfter, "Config after update should not be null");
            assertNotSame(configBefore, configAfter, "Config should be updated to the new InstagramConfig instance");

            // Passing null should not change config
            subscription.requestConfiguration(null);
            InstagramConfig configAfterNull = (InstagramConfig) configField.get(subscription);
            assertSame(configAfter, configAfterNull, "Config should remain unchanged when null is passed");

        } catch (NoSuchFieldException | IllegalAccessException e) {
            fail("Reflection failed to access config field: " + e.getMessage());
        }
    }
}
