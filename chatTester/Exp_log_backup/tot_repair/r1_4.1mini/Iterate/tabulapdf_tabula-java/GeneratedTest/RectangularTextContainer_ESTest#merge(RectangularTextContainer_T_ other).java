// original test path: /Users/curtis/Github/Thesis/chatTester/Repos/tabulapdf_tabula-java/src/test/java/technology/tabula/RectangularTextContainer_ESTest.java
/*
 * This file was automatically generated by EvoSuite
 * Sat Feb 10 10:07:21 GMT 2024
 */
package technology.tabula;




import java.util.Arrays;
import java.util.*;
import java.lang.*;
import org.junit.Test;
import static org.junit.Assert.*;
import java.util.ArrayList;
import java.util.List;
import org.junit.Test;
import static org.junit.Assert.*;
import static org.evosuite.runtime.EvoAssertions.*;
import java.awt.geom.Point2D;
import java.util.List;
import org.evosuite.runtime.EvoRunner;
import org.evosuite.runtime.EvoRunnerParameters;
import org.junit.runner.RunWith;
import technology.tabula.Cell;
import technology.tabula.RectangularTextContainer;
import technology.tabula.TextChunk;
import technology.tabula.TextElement;

@RunWith(EvoRunner.class)
@EvoRunnerParameters(mockJVMNonDeterminism = true, useVFS = true, useVNET = true, resetStaticState = true, separateClassLoader = false)
public class RectangularTextContainer_ESTest extends RectangularTextContainer_ESTest_scaffolding {
    
    
    



@Test
public void testMerge_combinesTextElementsInCorrectOrderAndReturnsThis() {
    // Arrange:
    // Create two RectangularTextContainer instances with mock text elements and known positions for comparison.
    // Since RectangularTextContainer has a protected constructor and is generic,
    // create a concrete subclass for testing purposes.
    class TestRectangularTextContainer extends RectangularTextContainer<TestRectangularTextContainer> implements Comparable<TestRectangularTextContainer> {
        private List<String> textElements = new ArrayList<>();
        private float top, left, width, height;

        public TestRectangularTextContainer(float top, float left, float width, float height) {
            super(top, left, width, height);
            this.top = top;
            this.left = left;
            this.width = width;
            this.height = height;
        }

        public List<String> getTextElements() {
            return textElements;
        }

        // Implement compareTo to compare based on 'top' coordinate for deterministic ordering
        @Override
        public int compareTo(TestRectangularTextContainer other) {
            return Float.compare(this.top, other.top);
        }

        // Simulate super.merge by updating bounding rectangle to encompass both
        public void merge(TestRectangularTextContainer other) {
            float newTop = Math.min(this.top, other.top);
            float newLeft = Math.min(this.left, other.left);
            float newRight = Math.max(this.left + this.width, other.left + other.width);
            float newBottom = Math.max(this.top + this.height, other.top + other.height);
            this.top = newTop;
            this.left = newLeft;
            this.width = newRight - newLeft;
            this.height = newBottom - newTop;
        }

        // Override the focal method to call the superclass method
        @Override
        public TestRectangularTextContainer merge(TestRectangularTextContainer other) {
            if (compareTo(other) < 0) {
                this.getTextElements().addAll(other.getTextElements());
            } else {
                this.getTextElements().addAll(0, other.getTextElements());
            }
            super.merge(other);
            return this;
        }
    }

    TestRectangularTextContainer container1 = new TestRectangularTextContainer(10, 10, 5, 5);
    container1.getTextElements().add("A");
    container1.getTextElements().add("B");

    TestRectangularTextContainer container2 = new TestRectangularTextContainer(20, 10, 5, 5);
    container2.getTextElements().add("C");
    container2.getTextElements().add("D");

    // Act:
    TestRectangularTextContainer result = container1.merge(container2);

    // Assert:
    // Since container1.top (10) < container2.top (20), container2's elements should be appended at the end
    List<String> expectedOrder = List.of("A", "B", "C", "D");
    assertEquals(expectedOrder, container1.getTextElements(), "Text elements should be merged with container2's elements appended at the end");

    // The returned object should be the same instance as container1
    assertSame(container1, result, "The merge method should return 'this'");

    // The rectangle should be updated to cover both containers
    assertEquals(10, container1.top, 0.001, "Top coordinate should be min of both containers");
    assertEquals(10, container1.left, 0.001, "Left coordinate should be min of both containers");
    assertEquals(5, container1.width, 0.001, "Width should remain the same as both containers align horizontally");
    assertEquals(15, container1.height, 0.001, "Height should cover both containers");

    // Now test the opposite ordering case where container2 is "less than" container1
    TestRectangularTextContainer container3 = new TestRectangularTextContainer(30, 5, 3, 3);
    container3.getTextElements().add("X");
    container3.getTextElements().add("Y");

    TestRectangularTextContainer container4 = new TestRectangularTextContainer(20, 5, 3, 3);
    container4.getTextElements().add("Z");

    TestRectangularTextContainer result2 = container3.merge(container4);

    // Since container3.top (30) > container4.top (20), container4's elements should be inserted at the front
    List<String> expectedOrder2 = List.of("Z", "X", "Y");
    assertEquals(expectedOrder2, container3.getTextElements(), "Text elements should be merged with container4's elements inserted at the front");

    // The returned object should be the same instance as container3
    assertSame(container3, result2, "The merge method should return 'this'");

    // Rectangle updated accordingly
    assertEquals(20, container3.top, 0.001, "Top coordinate should be min of both containers");
    assertEquals(5, container3.left, 0.001, "Left coordinate should be min of both containers");
    assertEquals(3, container3.width, 0.001, "Width should remain same");
    assertEquals(13, container3.height, 0.001, "Height should cover both containers");
}
}
