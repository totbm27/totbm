// original test path: /Users/curtis/Github/Thesis/chatTester/Repos/tabulapdf_tabula-java/src/test/java/technology/tabula/extractors/SpreadsheetExtractionAlgorithm_ESTest.java
/*
 * This file was automatically generated by EvoSuite
 * Sat Feb 10 09:51:32 GMT 2024
 */
package technology.tabula.extractors;





import java.awt.Rectangle;
import java.util.ArrayList;
import java.util.*;
import java.lang.*;
import org.junit.Test;
import static org.junit.Assert.*;
import static org.evosuite.runtime.EvoAssertions.*;
import java.util.LinkedList;
import java.util.List;
import org.evosuite.runtime.EvoRunner;
import org.evosuite.runtime.EvoRunnerParameters;
import org.junit.runner.RunWith;
import technology.tabula.Cell;
import technology.tabula.Page;
import technology.tabula.Rectangle;
import technology.tabula.Ruling;
import technology.tabula.extractors.SpreadsheetExtractionAlgorithm;

@RunWith(EvoRunner.class)
@EvoRunnerParameters(mockJVMNonDeterminism = true, useVFS = true, useVNET = true, resetStaticState = true, separateClassLoader = false)
public class SpreadsheetExtractionAlgorithm_ESTest extends SpreadsheetExtractionAlgorithm_ESTest_scaffolding {

    
    




@Test
public void testExtract_withMixedRulings_andMultipleSpreadsheetAreas_returnsSortedTables() {
    // Arrange:
    // Create a mock Page with text content for given cells
    Page page = new Page() {
        @Override
        public List<TextElement> getText(Cell cell) {
            // Return some dummy text elements based on cell bounds
            return Arrays.asList(new TextElement("Text for cell at " + cell.getBounds()));
        }

        @Override
        public int getPageNumber() {
            return 1;
        }
    };

    // Create horizontal rulings
    Ruling h1 = new Ruling(0, 10, 100, 10, true, false);  // horizontal at y=10
    Ruling h2 = new Ruling(0, 50, 100, 50, true, false);  // horizontal at y=50
    Ruling h3 = new Ruling(0, 90, 100, 90, true, false);  // horizontal at y=90

    // Create vertical rulings
    Ruling v1 = new Ruling(10, 0, 10, 100, false, true);  // vertical at x=10
    Ruling v2 = new Ruling(50, 0, 50, 100, false, true);  // vertical at x=50
    Ruling v3 = new Ruling(90, 0, 90, 100, false, true);  // vertical at x=90

    // Add rulings to a list mixed horizontal and vertical
    List<Ruling> rulings = Arrays.asList(h1, h2, h3, v1, v2, v3);

    // Create subclass with overridden methods to simulate the behavior
    SpreadsheetExtractionAlgorithm algo = new SpreadsheetExtractionAlgorithm() {
        @Override
        protected List<Ruling> collapseOrientedRulings(List<Ruling> rulings) {
            // Return rulings as is for test simplicity
            return rulings;
        }

        @Override
        protected List<Cell> findCells(List<Ruling> horizontal, List<Ruling> vertical) {
            // Create cells based on intersections of horizontal and vertical rulings
            List<Cell> cells = new ArrayList<>();
            // Horizontal lines at 10, 50, 90; vertical lines at 10, 50, 90
            // Cells between (10,10)-(50,50), (50,10)-(90,50), (10,50)-(50,90), (50,50)-(90,90)
            cells.add(new Cell(new Rectangle(10, 10, 40, 40))); // top-left cell
            cells.add(new Cell(new Rectangle(50, 10, 40, 40))); // top-right cell
            cells.add(new Cell(new Rectangle(10, 50, 40, 40))); // bottom-left cell
            cells.add(new Cell(new Rectangle(50, 50, 40, 40))); // bottom-right cell
            return cells;
        }

        @Override
        protected List<Rectangle> findSpreadsheetsFromCells(List<Cell> cells) {
            // Return one large rectangle covering all 4 cells
            return Arrays.asList(new Rectangle(10, 10, 80, 80));
        }
    };

    // Act:
    List<Table> tables = algo.extract(page, rulings);

    // Assert:
    assertNotNull(tables, "Extracted tables list should not be null");
    assertEquals(1, tables.size(), "There should be exactly one spreadsheet area detected");

    Table table = tables.get(0);
    assertTrue(table instanceof TableWithRulingLines, "Returned table should be of type TableWithRulingLines");

    TableWithRulingLines t = (TableWithRulingLines) table;

    // Check table boundaries
    Rectangle bounds = t.getBounds();
    assertEquals(10, bounds.getX());
    assertEquals(10, bounds.getY());
    assertEquals(80, bounds.getWidth());
    assertEquals(80, bounds.getHeight());

    // Check cells inside the table (should be 4)
    List<Cell> tableCells = t.getCells();
    assertEquals(4, tableCells.size(), "Table should contain 4 cells");

    // Each cell should have text elements set (merged words)
    for (Cell cell : tableCells) {
        List<TextElement> texts = cell.getTextElements();
        assertNotNull(texts, "Cell text elements should not be null");
        assertFalse(texts.isEmpty(), "Cell text elements should not be empty");
        // Text should contain the expected dummy text
        String text = texts.get(0).getText();
        assertTrue(text.contains("Text for cell at"), "Text element should contain expected content");
    }

    // Check horizontal rulings inside the table
    List<Ruling> horizontalRulings = t.getHorizontalRulings();
    assertEquals(3, horizontalRulings.size(), "Table should contain 3 horizontal rulings");

    // Check vertical rulings inside the table
    List<Ruling> verticalRulings = t.getVerticalRulings();
    assertEquals(3, verticalRulings.size(), "Table should contain 3 vertical rulings");

    // Check page number
    assertEquals(1, t.getPageNumber(), "Table should have correct page number");
}
}
