// original test path: /Users/curtis/Github/Thesis/chatTester/Repos/tabulapdf_tabula-java/src/test/java/technology/tabula/Rectangle_ESTest.java
/*
 * This file was automatically generated by EvoSuite
 * Sat Feb 10 10:03:59 GMT 2024
 */
package technology.tabula;

import org.junit.Test;
import static org.junit.Assert.*;
import java.util.LinkedList;
import java.util.List;
import technology.tabula.Rectangle;
import org.junit.Test;
import static org.junit.Assert.*;
import static org.evosuite.runtime.EvoAssertions.*;
import java.awt.geom.Point2D;
import java.awt.geom.Rectangle2D;
import java.util.LinkedList;
import java.util.List;
import org.evosuite.runtime.EvoRunner;
import org.evosuite.runtime.EvoRunnerParameters;
import org.junit.runner.RunWith;
import technology.tabula.Rectangle;

import org.junit.Test;
import static org.junit.Assert.*;
import technology.tabula.Rectangle;
import org.junit.Test;
import static org.junit.Assert.*;
import static org.evosuite.runtime.EvoAssertions.*;
import java.awt.geom.Point2D;
import java.awt.geom.Rectangle2D;
import java.util.LinkedList;
import java.util.List;
import org.evosuite.runtime.EvoRunner;
import org.evosuite.runtime.EvoRunnerParameters;
import org.junit.runner.RunWith;
import technology.tabula.Rectangle;

import static org.junit.Assert.assertEquals;
import org.junit.Test;
import org.junit.Test;
import static org.junit.Assert.*;
import static org.evosuite.runtime.EvoAssertions.*;
import java.awt.geom.Point2D;
import java.awt.geom.Rectangle2D;
import java.util.LinkedList;
import java.util.List;
import org.evosuite.runtime.EvoRunner;
import org.evosuite.runtime.EvoRunnerParameters;
import org.junit.runner.RunWith;
import technology.tabula.Rectangle;

import org.junit.Assert;
import org.junit.Test;
import org.junit.Test;
import static org.junit.Assert.*;
import static org.evosuite.runtime.EvoAssertions.*;
import java.awt.geom.Point2D;
import java.awt.geom.Rectangle2D;
import java.util.LinkedList;
import java.util.List;
import org.evosuite.runtime.EvoRunner;
import org.evosuite.runtime.EvoRunnerParameters;
import org.junit.runner.RunWith;
import technology.tabula.Rectangle;

import org.junit.Test;
import static org.junit.Assert.assertEquals;
import org.junit.Test;
import static org.junit.Assert.*;
import static org.evosuite.runtime.EvoAssertions.*;
import java.awt.geom.Point2D;
import java.awt.geom.Rectangle2D;
import java.util.LinkedList;
import java.util.List;
import org.evosuite.runtime.EvoRunner;
import org.evosuite.runtime.EvoRunnerParameters;
import org.junit.runner.RunWith;
import technology.tabula.Rectangle;

import java.util.*;
import java.lang.*;
import org.junit.Test;
import java.util.LinkedList;
import java.util.List;
import static org.junit.Assert.assertEquals;
import org.junit.Test;
import static org.junit.Assert.*;
import static org.evosuite.runtime.EvoAssertions.*;
import java.awt.geom.Point2D;
import java.awt.geom.Rectangle2D;
import java.util.LinkedList;
import java.util.List;
import org.evosuite.runtime.EvoRunner;
import org.evosuite.runtime.EvoRunnerParameters;
import org.junit.runner.RunWith;
import technology.tabula.Rectangle;

import static org.junit.Assert.*;
import org.junit.Test;
import java.awt.geom.Point2D;
import org.junit.Test;
import static org.junit.Assert.*;
import static org.evosuite.runtime.EvoAssertions.*;
import java.awt.geom.Point2D;
import java.awt.geom.Rectangle2D;
import java.util.LinkedList;
import java.util.List;
import org.evosuite.runtime.EvoRunner;
import org.evosuite.runtime.EvoRunnerParameters;
import org.junit.runner.RunWith;
import technology.tabula.Rectangle;

import org.junit.Test;
import static org.junit.Assert.*;
import java.util.Comparator;
import org.junit.Test;
import static org.junit.Assert.*;
import static org.evosuite.runtime.EvoAssertions.*;
import java.awt.geom.Point2D;
import java.awt.geom.Rectangle2D;
import java.util.LinkedList;
import java.util.List;
import org.evosuite.runtime.EvoRunner;
import org.evosuite.runtime.EvoRunnerParameters;
import org.junit.runner.RunWith;
import technology.tabula.Rectangle;

import java.util.*;
import java.lang.*;
import org.junit.Test;
import static org.junit.Assert.assertEquals;
import org.junit.Test;
import static org.junit.Assert.*;
import static org.evosuite.runtime.EvoAssertions.*;
import java.awt.geom.Point2D;
import java.awt.geom.Rectangle2D;
import java.util.LinkedList;
import java.util.List;
import org.evosuite.runtime.EvoRunner;
import org.evosuite.runtime.EvoRunnerParameters;
import org.junit.runner.RunWith;
import technology.tabula.Rectangle;

@RunWith(EvoRunner.class)
@EvoRunnerParameters(mockJVMNonDeterminism = true, useVFS = true, useVNET = true, resetStaticState = true, separateClassLoader = false)
public class Rectangle_ESTest extends Rectangle_ESTest_scaffolding {


    @Test
    public void testVerticalOverlapRatio() {
        // Create two rectangles for testing
        Rectangle rect1 = new Rectangle(0, 0, 10, 10);
        Rectangle rect2 = new Rectangle(5, 5, 10, 10);

        // Calculate the expected vertical overlap ratio manually
        float rect1Top = rect1.getTop();
        float rect1Bottom = rect1.getBottom();
        float rect2Top = rect2.getTop();
        float rect2Bottom = rect2.getBottom();
        float delta = Math.min(rect1Bottom - rect1Top, rect2Bottom - rect2Top);
        float expectedRatio = (Math.min(rect1Bottom, rect2Bottom) - Math.max(rect1Top, rect2Top)) / delta;

        // Call the method under test
        float actualRatio = rect1.verticalOverlapRatio(rect2);

        // Assert that the calculated ratio matches the expected ratio
        Assert.assertEquals(expectedRatio, actualRatio, 0.001); // Using delta for float comparison
    }


    @Test
    public void testHorizontalOverlap() {
        // Create two rectangles for testing
        Rectangle rectangle1 = new Rectangle(0, 0, 5, 5); // Rectangle with top-left corner at (0,0) and width/height of 5
        Rectangle rectangle2 = new Rectangle(3, 2, 6, 4); // Rectangle with top-left corner at (3,2) and width/height of 6

        // Calculate the expected horizontal overlap manually
        float expectedOverlap = Math.max(0, Math.min(rectangle1.getRight(), rectangle2.getRight()) - Math.max(rectangle1.getLeft(), rectangle2.getLeft()));

        // Call the method to calculate horizontal overlap
        float actualOverlap = rectangle1.horizontalOverlap(rectangle2);

        // Assert that the calculated overlap matches the expected overlap
        assertEquals(expectedOverlap, actualOverlap, 0.001); // Using delta for float comparison
    }


    @Test
    public void testGetPoints() {
        Rectangle rectangle = new Rectangle(0, 0, 5, 3);
        Point2D[] expectedPoints = {
            new Point2D.Float(0, 0),
            new Point2D.Float(5, 0),
            new Point2D.Float(5, 3),
            new Point2D.Float(0, 3)
        };

        Point2D[] actualPoints = rectangle.getPoints();

        assertEquals(expectedPoints.length, actualPoints.length);
        for (int i = 0; i < expectedPoints.length; i++) {
            assertEquals(expectedPoints[i].getX(), actualPoints[i].getX(), 0.001);
            assertEquals(expectedPoints[i].getY(), actualPoints[i].getY(), 0.001);
        }
    }


    @Test
    public void testOverlapRatio() {
        // Create two rectangles for testing
        Rectangle rectangle1 = new Rectangle(0, 0, 5, 5); // Rectangle with top-left corner at (0,0) and width=5, height=5
        Rectangle rectangle2 = new Rectangle(3, 3, 5, 5); // Rectangle with top-left corner at (3,3) and width=5, height=5

        // Calculate the expected overlap ratio manually
        double expectedIntersectionWidth = Math.max(0, Math.min(rectangle1.getRight(), rectangle2.getRight()) - Math.max(rectangle1.getLeft(), rectangle2.getLeft()));
        double expectedIntersectionHeight = Math.max(0, Math.min(rectangle1.getBottom(), rectangle2.getBottom()) - Math.max(rectangle1.getTop(), rectangle2.getTop()));
        double expectedIntersectionArea = Math.max(0, expectedIntersectionWidth * expectedIntersectionHeight);
        double expectedUnionArea = rectangle1.getArea() + rectangle2.getArea() - expectedIntersectionArea;
        float expectedOverlapRatio = (float) (expectedIntersectionArea / expectedUnionArea);

        // Calculate the actual overlap ratio using the method under test
        float actualOverlapRatio = rectangle1.overlapRatio(rectangle2);

        // Assert that the actual overlap ratio matches the expected overlap ratio
        Assert.assertEquals(expectedOverlapRatio, actualOverlapRatio, 0.001); // Allowing for a small delta for floating-point comparison
    }


    @Test
    public void testVerticalOverlap() {
        Rectangle rectangle1 = new Rectangle(0, 0, 5, 5);
        Rectangle rectangle2 = new Rectangle(2, 2, 6, 6);
        
        float expectedOverlap = 3; // Expected vertical overlap between rectangle1 and rectangle2
        
        float actualOverlap = rectangle1.verticalOverlap(rectangle2);
        
        assertEquals(expectedOverlap, actualOverlap, 0.001); // Allowing for a small margin of error
    }


    @Test
    public void testSetTop() {
        // Given
        float initialTop = 10.0f;
        float initialLeft = 5.0f;
        float initialWidth = 20.0f;
        float initialHeight = 15.0f;
        
        Rectangle rectangle = new Rectangle(initialTop, initialLeft, initialWidth, initialHeight);
        
        // When
        float newTop = 20.0f;
        rectangle.setTop(newTop);
        
        // Then
        assertEquals(newTop, rectangle.getTop(), 0.001f); // Tolerance of 0.001f for float comparison
        assertEquals(initialLeft, rectangle.getLeft(), 0.001f); // Left coordinate should remain unchanged
        assertEquals(initialWidth, rectangle.getWidth(), 0.001f); // Width should remain unchanged
        assertEquals(initialHeight - (newTop - initialTop), rectangle.getHeight(), 0.001f); // Height should adjust accordingly
    }


    @Test
    public void testGetRight() {
        Rectangle rectangle = new Rectangle(0, 0, 5, 10);
        float expectedRight = 5.0f;
        float actualRight = rectangle.getRight();
        assertEquals(expectedRight, actualRight, 0.001);
    }


    
    @Test
    public void testIsLtrDominant() {
        Rectangle rectangle = new Rectangle(0, 0, 10, 5);
        assertTrue(rectangle.getWidth() > rectangle.getHeight());
    }


    @Test
    public void testCompareTo() {
        Rectangle rectangle1 = new Rectangle(0, 0, 10, 10);
        Rectangle rectangle2 = new Rectangle(5, 5, 10, 10);

        int expectedComparisonResult = Rectangle.ILL_DEFINED_ORDER.compare(rectangle1, rectangle2);
        int actualComparisonResult = rectangle1.compareTo(rectangle2);

        assertEquals(expectedComparisonResult, actualComparisonResult);
    }


    @Test
    public void testGetBottom() {
        Rectangle rectangle = new Rectangle(0, 0, 10, 20);
        float expectedBottom = 20.0f;
        float actualBottom = rectangle.getBottom();
        
        assertEquals(expectedBottom, actualBottom, 0.001);
    }


    @Test
    public void testGetLeft() {
        Rectangle rectangle = new Rectangle(0, 0, 10, 5); // Creating a Rectangle object with top-left corner at (0,0), width 10, height 5
        float expectedLeft = 0; // Expected leftmost x-coordinate of the rectangle

        float actualLeft = rectangle.getLeft(); // Getting the leftmost x-coordinate using getLeft() method

        assertEquals(expectedLeft, actualLeft, 0.001); // Asserting that the actual leftmost x-coordinate matches the expected value
    }


    @Test
    public void testVerticallyOverlaps() {
        // Create two rectangles for testing
        Rectangle rect1 = new Rectangle(0, 0, 5, 5); // Rectangle with top-left corner at (0,0) and dimensions 5x5
        Rectangle rect2 = new Rectangle(3, 2, 4, 4); // Rectangle with top-left corner at (2,3) and dimensions 4x4

        // Test when rectangles vertically overlap
        assertTrue(rect1.verticallyOverlaps(rect2));

        // Test when rectangles do not vertically overlap
        Rectangle rect3 = new Rectangle(10, 10, 3, 3); // Rectangle far away from rect1
        assertFalse(rect1.verticallyOverlaps(rect3));
    }


    @Test
    public void testSetBottom() {
        // Given
        float initialTop = 10.0f;
        float initialLeft = 5.0f;
        float initialWidth = 20.0f;
        float initialHeight = 15.0f;
        float newBottom = 25.0f;
        
        Rectangle rectangle = new Rectangle(initialTop, initialLeft, initialWidth, initialHeight);
        
        // When
        rectangle.setBottom(newBottom);
        
        // Then
        assertEquals(initialTop, rectangle.getTop(), 0.0f); // Top coordinate should remain unchanged
        assertEquals(initialLeft, rectangle.getLeft(), 0.0f); // Left coordinate should remain unchanged
        assertEquals(initialWidth, rectangle.getRight() - rectangle.getLeft(), 0.0f); // Width should remain unchanged
        assertEquals(newBottom - initialTop, rectangle.getBottom() - rectangle.getTop(), 0.0f); // Height should be updated to new bottom coordinate
    }


    @Test
    public void testGetTop() {
        Rectangle rectangle = new Rectangle(10.0f, 5.0f, 20.0f, 15.0f);
        float expectedTop = 10.0f;
        float actualTop = rectangle.getTop();
        assertEquals(expectedTop, actualTop, 0.001f);
    }


    
    @Test
    public void testSetLeft() {
        float initialLeft = 10.0f;
        float initialTop = 20.0f;
        float initialWidth = 30.0f;
        float initialHeight = 40.0f;
        Rectangle rectangle = new Rectangle(initialTop, initialLeft, initialWidth, initialHeight);
        float newLeft = 5.0f;
        rectangle.setLeft(newLeft);
        assertEquals(newLeft, rectangle.getLeft(), 0.001f);
        assertEquals(initialWidth + (initialLeft - newLeft), rectangle.getWidth(), 0.001f);
        assertEquals(initialTop, rectangle.getTop(), 0.001f);
        assertEquals(initialHeight, rectangle.getHeight(), 0.001f);
    }


    @Test
    public void testGetArea() {
        // Given
        float width = 5.0f;
        float height = 10.0f;
        Rectangle rectangle = new Rectangle(0.0f, 0.0f, width, height);

        // When
        float area = rectangle.getArea();

        // Then
        assertEquals(width * height, area, 0.001); // Allowing for floating-point precision
    }


    
    
    
@Test
public void testSetRight() {
    // Arrange:
    Rectangle rectangle = new Rectangle(0, 0, 5, 10);
    
    // Act:
    rectangle.setRight(10);
    
    // Assert:
    assertEquals(10, rectangle.getRight(), 0);
    assertEquals(10, rectangle.getWidth(), 0);
}



@Test
public void testToString() {
    Rectangle rectangle = new Rectangle(10, 20, 30, 40);
    String expected = "Rectangle[x=10.0,y=20.0,width=30.0,height=40.0,bottom=50.0,right=40.0]";
    String actual = rectangle.toString();
   
}


    @Test
    public void testMerge() {
        // Create the first rectangle
        Rectangle rectangle1 = new Rectangle(0, 0, 5, 5);
        
        // Create the second rectangle
        Rectangle rectangle2 = new Rectangle(2, 2, 6, 6);
        
        // Merge the rectangles
        Rectangle mergedRectangle = rectangle1.merge(rectangle2);
        
        // Check if the merged rectangle dimensions are correct
        assertEquals(0, mergedRectangle.getLeft(), 0.001);
        assertEquals(0, mergedRectangle.getTop(), 0.001);
        assertEquals(8, mergedRectangle.getRight(), 0.001);
        assertEquals(8, mergedRectangle.getBottom(), 0.001);
    }



@Test
public void testBoundingBoxOf() {
    List<Rectangle> rectangles = new LinkedList<>();
    rectangles.add(new Rectangle(0, 0, 5, 5));
    rectangles.add(new Rectangle(2, 3, 4, 6));
    rectangles.add(new Rectangle(1, 1, 3, 3));
    float expectedMinX = 0;
    float expectedMinY = 0;
    float expectedMaxX = 6;
    float expectedMaxY = 9;
    Rectangle boundingBox = Rectangle.boundingBoxOf(rectangles);
    assertEquals(expectedMinX, boundingBox.getMinX(), 0.001);
    assertEquals(expectedMinY, boundingBox.getMinY(), 0.001);
        
}


    @Test
    public void testHorizontallyOverlaps_WhenOverlap_ReturnsTrue() {
        // Create two rectangles with horizontal overlap
        Rectangle rectangle1 = new Rectangle(0, 0, 5, 5);
        Rectangle rectangle2 = new Rectangle(3, 2, 5, 5);

        // Check if the rectangles horizontally overlap
        assertTrue(rectangle1.horizontallyOverlaps(rectangle2));
    }

}
