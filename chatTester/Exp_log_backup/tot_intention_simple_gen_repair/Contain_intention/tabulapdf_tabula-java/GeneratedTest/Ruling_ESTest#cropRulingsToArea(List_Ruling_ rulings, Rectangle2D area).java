// original test path: /Users/curtis/Github/Thesis/chatTester/Repos/tabulapdf_tabula-java/src/test/java/technology/tabula/Ruling_ESTest.java
/*
 * This file was automatically generated by EvoSuite
 * Sat Feb 10 10:09:27 GMT 2024
 */
package technology.tabula;

import org.junit.Test;
import static org.junit.Assert.*;
import static org.evosuite.runtime.EvoAssertions.*;
import java.awt.Point;
import java.awt.geom.Point2D;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import org.evosuite.runtime.EvoRunner;
import org.evosuite.runtime.EvoRunnerParameters;
import org.junit.runner.RunWith;
import technology.tabula.Ruling;

@RunWith(EvoRunner.class)
@EvoRunnerParameters(mockJVMNonDeterminism = true, useVFS = true, useVNET = true, resetStaticState = true, separateClassLoader = false)
public class Ruling_ESTest extends Ruling_ESTest_scaffolding {
@Test
public void testCropRulingsToArea() {
    // Define the rectangular area: left=10, top=10, width=50, height=50
    Rectangle2D area = new Rectangle2D.Float(10, 10, 50, 50);

    // 1) Ruling fully contained within the area
    // From (20, 20) to (40, 20) - horizontal line fully inside
    Ruling fullyInside = new Ruling(20f, 20f, 20f, 0f);

    // 2) Ruling partially overlapping the area
    // From (5, 5) to (30, 30) - diagonal line partially inside
    Ruling partiallyOverlapping = new Ruling(new Point2D.Float(5f, 5f), new Point2D.Float(30f, 30f));

    // 3) Ruling completely outside the area
    // From (0, 0) to (5, 5) - diagonal line fully outside
    Ruling fullyOutside = new Ruling(new Point2D.Float(0f, 0f), new Point2D.Float(5f, 5f));

    // 4) Ruling exactly aligned along one edge of the area
    // Horizontal line along top edge from (10, 10) to (60, 10)
    Ruling onBoundary = new Ruling(10f, 10f, 50f, 0f);

    List<Ruling> rulings = new LinkedList<>();
    rulings.add(fullyInside);
    rulings.add(partiallyOverlapping);
    rulings.add(fullyOutside);
    rulings.add(onBoundary);

    List<Ruling> cropped = Ruling.cropRulingsToArea(rulings, area);

    // We expect 3 rulings in the result: fullyInside, partiallyOverlapping (cropped), onBoundary
    // fullyOutside should be excluded
    // Check size
    org.junit.Assert.assertEquals(3, cropped.size());

    // Check that fullyInside ruling is unchanged (equals original)
    boolean foundFullyInside = false;
    boolean foundOnBoundary = false;
    boolean foundPartiallyOverlapping = false;

    for (Ruling r : cropped) {
        // fullyInside: from (20,20) to (40,20)
        if (r.getStart() == fullyInside.getStart() && r.getEnd() == fullyInside.getEnd() &&
            r.getTop() == fullyInside.getTop() && r.getLeft() == fullyInside.getLeft()) {
            foundFullyInside = true;
        }
        // onBoundary: from (10,10) to (60,10) cropped to (10,10) to (60,10) but area width is 50, so right edge is 60
        // Actually, area right edge = 10 + 50 = 60, so onBoundary should remain same
        if (r.getTop() == onBoundary.getTop() && r.getLeft() == onBoundary.getLeft() &&
            r.getRight() == onBoundary.getRight()) {
            foundOnBoundary = true;
        }
        // partiallyOverlapping: original from (5,5) to (30,30), cropped to area (10,10) to (30,30)
        // So start point should be at or inside area bounds
        if (r.getTop() >= area.getY() && r.getLeft() >= area.getX() &&
            r.getTop() <= area.getY() + area.getHeight() &&
            r.getLeft() <= area.getX() + area.getWidth()) {
            // Check if this ruling is the cropped partially overlapping one by checking length and points
            if (r.length() < partiallyOverlapping.length() && r.length() > 0) {
                foundPartiallyOverlapping = true;
            }
        }
    }

    org.junit.Assert.assertTrue("Fully inside ruling should be present", foundFullyInside);
    org.junit.Assert.assertTrue("On boundary ruling should be present", foundOnBoundary);
    org.junit.Assert.assertTrue("Partially overlapping ruling should be present and cropped", foundPartiallyOverlapping);
}
}
