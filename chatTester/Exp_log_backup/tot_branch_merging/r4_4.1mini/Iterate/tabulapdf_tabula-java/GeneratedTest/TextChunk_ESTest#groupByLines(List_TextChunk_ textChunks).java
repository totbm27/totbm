// original test path: /Users/curtis/Github/Thesis/chatTester/Repos/tabulapdf_tabula-java/src/test/java/technology/tabula/TextChunk_ESTest.java
/*
 * This file was automatically generated by EvoSuite
 * Sat Feb 10 10:15:23 GMT 2024
 */
package technology.tabula;





import java.util.Arrays;
import java.awt.Rectangle;
import java.util.*;
import java.lang.*;
import org.junit.Test;
import static org.junit.Assert.*;
import static org.evosuite.runtime.EvoAssertions.*;
import java.awt.geom.Rectangle2D;
import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import org.evosuite.runtime.EvoRunner;
import org.evosuite.runtime.EvoRunnerParameters;
import org.junit.runner.RunWith;
import technology.tabula.Line;
import technology.tabula.Rectangle;
import technology.tabula.TextChunk;
import technology.tabula.TextElement;

@RunWith(EvoRunner.class)
@EvoRunnerParameters(mockJVMNonDeterminism = true, useVFS = true, useVNET = true, resetStaticState = true, separateClassLoader = false)
public class TextChunk_ESTest extends TextChunk_ESTest_scaffolding {

    




@Test
public void testGroupByLines_variousCases() {
    // Arrange:
    // Prepare TextChunk stubs with minimal necessary methods and data.
    // Since TextChunk extends Rectangle and uses TextElement, we'll create minimal stubs.

    class TextElement {
        float x, y, width, height;
        char c;
        TextElement(float y, float x, float width, float height, char c) {
            this.x = x; this.y = y; this.width = width; this.height = height; this.c = c;
        }
    }

    class Rectangle {
        float x, y, width, height;
        Rectangle(float y, float x, float width, float height) {
            this.x = x; this.y = y; this.width = width; this.height = height;
        }

        static Rectangle boundingBoxOf(List<TextChunk> chunks) {
            if (chunks.isEmpty()) return new Rectangle(0,0,0,0);
            float minX = Float.MAX_VALUE, minY = Float.MAX_VALUE;
            float maxX = Float.MIN_VALUE, maxY = Float.MIN_VALUE;
            for (TextChunk tc : chunks) {
                if (tc.x < minX) minX = tc.x;
                if (tc.y < minY) minY = tc.y;
                if (tc.x + tc.width > maxX) maxX = tc.x + tc.width;
                if (tc.y + tc.height > maxY) maxY = tc.y + tc.height;
            }
            return new Rectangle(minY, minX, maxX - minX, maxY - minY);
        }
    }

    class TextChunk extends Rectangle {
        private final List<TextElement> elements = new ArrayList<>();
        TextChunk(float top, float left, float width, float height) {
            super(top, left, width, height);
        }
        TextChunk(TextElement textElement) {
            super(textElement.y, textElement.x, textElement.width, textElement.height);
            this.elements.add(textElement);
        }
        TextChunk(List<TextElement> textElements) {
            this(textElements.get(0));
            for(int i = 1; i < textElements.size(); i++) {
                this.elements.add(textElements.get(i));
            }
        }
        public void add(TextElement e) {
            elements.add(e);
        }
        public List<TextElement> getTextElements() {
            return elements;
        }
        // vertical overlap ratio between this chunk and another chunk
        public float verticalOverlapRatio(TextChunk other) {
            float thisTop = this.y;
            float thisBottom = this.y + this.height;
            float otherTop = other.y;
            float otherBottom = other.y + other.height;
            float overlap = Math.min(thisBottom, otherBottom) - Math.max(thisTop, otherTop);
            if (overlap <= 0) return 0f;
            float minHeight = Math.min(this.height, other.height);
            return overlap / minHeight;
        }
        // checks if all text elements have the same character
        public static boolean allSameChar(List<TextElement> elements) {
            if (elements.isEmpty()) return true;
            char first = elements.get(0).c;
            for (TextElement e : elements) {
                if (e.c != first) return false;
            }
            return true;
        }

        // The focal method groupByLines copied here for testing:
        public static List<Line> groupByLines(List<TextChunk> textChunks) {
            List<Line> lines = new ArrayList<>();
            if (textChunks.size() == 0) {
                return lines;
            }
            float bbwidth = Rectangle.boundingBoxOf(textChunks).width;
            Line l = new Line();
            l.addTextChunk(textChunks.get(0));
            textChunks.remove(0);
            lines.add(l);
            Line last = lines.get(lines.size() - 1);
            for (TextChunk te : textChunks) {
                if (last.verticalOverlapRatio(te) < 0.1) {
                    if (last.width / bbwidth > 0.9 && TextChunk.allSameChar(last.getTextElements())) {
                        lines.remove(lines.size() - 1);
                    }
                    lines.add(new Line());
                    last = lines.get(lines.size() - 1);
                }
                last.addTextChunk(te);
            }
            if (last.width / bbwidth > 0.9 && TextChunk.allSameChar(last.getTextElements())) {
                lines.remove(lines.size() - 1);
            }
            List<Line> rv = new ArrayList<>(lines.size());
            for (Line line : lines) {
                rv.add(Line.removeRepeatedCharacters(line, ' ', 3));
            }
            return rv;
        }
    }

    class Line {
        private final List<TextChunk> chunks = new ArrayList<>();
        float width = 0;
        void addTextChunk(TextChunk tc) {
            chunks.add(tc);
            float right = tc.x + tc.width;
            if (right > width) width = right;
        }
        List<TextElement> getTextElements() {
            List<TextElement> all = new ArrayList<>();
            for(TextChunk tc : chunks) {
                all.addAll(tc.getTextElements());
            }
            return all;
        }
        // removes repeated characters with minimum count threshold
        static Line removeRepeatedCharacters(Line line, char ch, int minCount) {
            List<TextElement> filtered = new ArrayList<>();
            List<TextElement> elems = line.getTextElements();
            int count = 0;
            for (TextElement e : elems) {
                if (e.c == ch) {
                    count++;
                } else {
                    count = 0;
                }
                if (count <= minCount) {
                    filtered.add(e);
                }
            }
            // Create a new Line with filtered TextChunks (simplified as one chunk here)
            if(filtered.isEmpty()) return new Line();
            List<TextElement> filteredElems = filtered;
            TextChunk filteredChunk = new TextChunk(filteredElems);
            Line newLine = new Line();
            newLine.addTextChunk(filteredChunk);
            return newLine;
        }
    }

    // Compose test inputs for different scenarios:

    // Case 1: Empty input list should return empty list
    List<TextChunk> emptyInput = new ArrayList<>();

    // Case 2: Single TextChunk (single line)
    TextElement te1 = new TextElement(0, 0, 10, 2, 'a');
    TextChunk chunk1 = new TextChunk(te1);
    List<TextChunk> singleLineInput = new ArrayList<>();
    singleLineInput.add(chunk1);

    // Case 3: Multiple TextChunks overlapping vertically (same line)
    TextElement te2 = new TextElement(0, 11, 10, 2, 'b');
    TextChunk chunk2 = new TextChunk(te2);
    List<TextChunk> multiLineInputOverlap = new ArrayList<>(Arrays.asList(chunk1, chunk2));

    // Case 4: Multiple TextChunks non-overlapping vertically (different lines)
    TextElement te3 = new TextElement(5, 0, 10, 2, 'c');
    TextChunk chunk3 = new TextChunk(te3);
    List<TextChunk> multiLineInputNoOverlap = new ArrayList<>(Arrays.asList(chunk1, chunk3));

    // Case 5: Line mostly consists of repeated char spanning nearly entire bounding box width (should be removed)
    // Create repeated 'x' characters covering >90% width
    List<TextElement> repeatedElements = new ArrayList<>();
    for (int i = 0; i < 5; i++) {
        repeatedElements.add(new TextElement(10, i * 10, 10, 2, 'x'));
    }
    TextChunk repeatedChunk = new TextChunk(repeatedElements);
    List<TextChunk> repeatedLineInput = new ArrayList<>();
    repeatedLineInput.add(repeatedChunk);

    // Act:
    // Call groupByLines for each case
    List<Line> resultEmpty = TextChunk.groupByLines(new ArrayList<>(emptyInput));

    List<Line> resultSingle = TextChunk.groupByLines(new ArrayList<>(singleLineInput));

    List<Line> resultOverlap = TextChunk.groupByLines(new ArrayList<>(multiLineInputOverlap));

    List<Line> resultNoOverlap = TextChunk.groupByLines(new ArrayList<>(multiLineInputNoOverlap));

    List<Line> resultRepeated = TextChunk.groupByLines(new ArrayList<>(repeatedLineInput));

    // Assert:

    // Case 1: empty input returns empty list
    assertNotNull(resultEmpty);
    assertTrue(resultEmpty.isEmpty());

    // Case 2: single TextChunk returns one line containing that chunk's text elements
    assertEquals(1, resultSingle.size());
    Line lineSingle = resultSingle.get(0);
    List<TextElement> elemsSingle = lineSingle.getTextElements();
    assertEquals(1, elemsSingle.size());
    assertEquals('a', elemsSingle.get(0).c);

    // Case 3: overlapping TextChunks grouped into one line (overlap >= 0.1)
    assertEquals(1, resultOverlap.size());
    Line lineOverlap = resultOverlap.get(0);
    List<TextElement> elemsOverlap = lineOverlap.getTextElements();
    assertEquals(2, elemsOverlap.size());
    List<Character> charsOverlap = Arrays.asList(elemsOverlap.get(0).c, elemsOverlap.get(1).c);
    assertTrue(charsOverlap.contains('a') && charsOverlap.contains('b'));

    // Case 4: non-overlapping TextChunks form separate lines
    assertEquals(2, resultNoOverlap.size());
    Line line0 = resultNoOverlap.get(0);
    Line line1 = resultNoOverlap.get(1);
    assertEquals(1, line0.getTextElements().size());
    assertEquals(1, line1.getTextElements().size());
    assertEquals('a', line0.getTextElements().get(0).c);
    assertEquals('c', line1.getTextElements().get(0).c);

    // Case 5: repeated chars line spanning > 90% width is removed, so result is empty
    assertTrue(resultRepeated.isEmpty());
}
}
